{
  "path": "/docs/schema-gql-type/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"GraphQL Node Types Creation\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This documentation isn\\u2019t up to date with latest\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-customization\"\n  }), \"schema customization changes\"), \". Help Gatsby by\\nmaking a PR to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/14228\"\n  }), \"update this documentation\"), \"!\")), mdx(\"p\", null, \"Gatsby creates a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/graphql-js/type/#graphqlobjecttype\"\n  }), \"GraphQLObjectType\"), \" for each distinct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node.internal.type\"), \" that is created during the source-nodes phase. Find out below how this is done.\"), mdx(\"h2\", {\n    \"id\": \"graphql-types-for-each-type-of-node\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#graphql-types-for-each-type-of-node\",\n    \"aria-label\": \"graphql types for each type of node permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"GraphQL Types for each type of node\"), mdx(\"p\", null, \"When running a GraphQL query, there are a variety of fields that you will want to query. Let\\u2019s take an example, say we have the below query:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  file( relativePath: {  eq: `blogs/my-blog.md` } ) {\\n    childMarkdownRemark {\\n      frontmatter: {\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"When GraphQL runs, it will query all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"file\"), \" nodes by their relativePath and return the first node that satisfies that query. Then, it will filter down the fields to return by the inner expression. I.e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{ childMarkdownRemark ... }\"), \". The building of the query arguments is covered by the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-input-gql\"\n  }), \"Inferring Input Filters\"), \" doc. This section instead explains how the inner filter schema is generated (it must be generated before input filters are inferred).\"), mdx(\"p\", null, \"During the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#sourceNodes\"\n  }), \"sourceNodes\"), \" phase, let\\u2019s say that \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/packages/gatsby-source-filesystem\"\n  }), \"gatsby-source-filesystem\"), \" ran and created a bunch of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" nodes. Then, different transformers react via \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#onCreateNode\"\n  }), \"onCreateNode\"), \", resulting in children of different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node.internal.type\"), \"s being created.\"), mdx(\"p\", null, \"There are 3 categories of node fields that we can query.\"), mdx(\"h4\", {\n    \"id\": \"fields-on-the-created-node-object-eg\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#fields-on-the-created-node-object-eg\",\n    \"aria-label\": \"fields on the created node object eg permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Fields on the created node object. E.g\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"node {\\n  relativePath,\\n  extension,\\n  size,\\n  accessTime\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"childparent-eg\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#childparent-eg\",\n    \"aria-label\": \"childparent eg permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Child/Parent. E.g:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"node {\\n  childMarkdownRemark,\\n  childrenPostsJson,\\n  children,\\n  parent\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"fields-created-by-setfieldsongraphqlnodetype\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#fields-created-by-setfieldsongraphqlnodetype\",\n    \"aria-label\": \"fields created by setfieldsongraphqlnodetype permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"fields created by setFieldsOnGraphQLNodeType\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"node {\\n  publicURL\\n}\\n\")), mdx(\"p\", null, \"Each of these categories of fields is created in a different way, explained below.\"), mdx(\"h2\", {\n    \"id\": \"gqltype-creation\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#gqltype-creation\",\n    \"aria-label\": \"gqltype creation permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"gqlType Creation\"), mdx(\"p\", null, \"The Gatsby term for the GraphQLObjectType for a unique node type, is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gqlType\"), \". GraphQLObjectTypes are simply objects that define the type name and fields. The field definitions are created by the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L48\"\n  }), \"createNodeFields\"), \" function in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"build-node-types.js\"), \".\"), mdx(\"p\", null, \"An important thing to note is that all gqlTypes are created before their fields are inferred. This allows fields to be of types that haven\\u2019t yet been created due to their order of compilation. This is accomplished by the use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fields\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L167\"\n  }), \"being a function\"), \" (basically lazy functions).\"), mdx(\"p\", null, \"The first step in inferring GraphQL Fields is to generate an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exampleValue\"), \". It is the result of merging all fields of all nodes of the type in question. This \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exampleValue\"), \" will therefore contain all potential field names and values, which allows us to infer each field\\u2019s types. The logic to create it is in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/data-tree-utils.js#L305\"\n  }), \"getExampleValues\"), \".\"), mdx(\"p\", null, \"With the exampleValue in hand, we can use each of its key/values to infer the Type\\u2019s fields (broken down by the 3 categories above).\"), mdx(\"h3\", {\n    \"id\": \"fields-on-the-created-node-object\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#fields-on-the-created-node-object\",\n    \"aria-label\": \"fields on the created node object permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Fields on the created node object\"), mdx(\"p\", null, \"Fields on the node that were created directly by the source and transform plugins. E.g for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" type, these would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"relativePath\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"size\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accessTime\"), \" etc.\"), mdx(\"p\", null, \"The creation of these fields is handled by the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L317\"\n  }), \"inferObjectStructureFromNodes\"), \" function in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js\"\n  }), \"infer-graphql-type.js\"), \". Given an object, a field could be in one of 3 sub-categories:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It involves a mapping in \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/gatsby-config/#mapping-node-types\"\n  }), \"gatsby-config.js\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It\\u2019s value is a foreign key reference to some other node (ends in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"___NODE\"), \")\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It\\u2019s a plain object or value (e.g String, number, etc)\")), mdx(\"h4\", {\n    \"id\": \"mapping-field\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#mapping-field\",\n    \"aria-label\": \"mapping field permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Mapping field\"), mdx(\"p\", null, \"Mappings are explained in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/gatsby-config/#mapping-node-types\"\n  }), \"gatsby-config.js docs\"), \". If the object field we\\u2019re generating a GraphQL type for is configured in the gatsby-config mapping, then we handle it specially.\"), mdx(\"p\", null, \"Imagine our top level Type we\\u2019re currently generating fields for is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark.frontmatter\"), \". And the field we are creating a GraphQL field for is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author\"), \". And, that we have a mapping setup of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"mapping: {\\n  \\\"MarkdownRemark.frontmatter.author\\\": `AuthorYaml.name`,\\n},\\n\")), mdx(\"p\", null, \"The field generation in this case is handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L129\"\n  }), \"inferFromMapping\"), \". The first step is to find the type that is mapped to. In this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorYaml\"), \". This is known as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"linkedType\"), \". That type will have a field to link by. In this case \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \". If one is not supplied, it defaults to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \". This field is known as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"linkedField\")), mdx(\"p\", null, \"Now we can create a GraphQL Field declaration whose type is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorYaml\"), \" (which we look up in list of other \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gqlTypes\"), \"). The field resolver will get the value for the node (in this case, the author string), and then search through the react nodes until it finds one whose type is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorYaml\"), \" and whose \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" field matches the author string.\"), mdx(\"h4\", {\n    \"id\": \"foreign-key-reference-___node\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#foreign-key-reference-___node\",\n    \"aria-label\": \"foreign key reference ___node permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Foreign Key reference (\", mdx(\"inlineCode\", {\n    parentName: \"h4\"\n  }, \"___NODE\"), \")\"), mdx(\"p\", null, \"If not a mapping field, it might instead end in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \", signifying that its value is an ID that is a foreign key reference to another node in redux. Check out the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/pixabay-source-plugin-tutorial/\"\n  }), \"Source Plugin Tutorial\"), \" for how this works from a user point of view. Behind the scenes, the field inference is handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L204\"\n  }), \"inferFromFieldName\"), \".\"), mdx(\"p\", null, \"This is actually quite similar to the mapping case above. We remove the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \" part of the field name. E.g \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author___NODE\"), \" would become \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author\"), \". Then, we find our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"linkedNode\"), \". I.e given the example value for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author\"), \" (which would be an ID), we find its actual node in redux. Then, we find its type in processed types by its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal.type\"), \". Note, that also like in mapping fields, we can define the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"linkedField\"), \" too. This can be specified via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodeFieldname___NODE___linkedFieldName\"), \". E.g for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author___NODE___name\"), \", the linkedField would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \".\"), mdx(\"p\", null, \"Now we can return a new GraphQL Field object, whose type is the one found above. Its resolver searches through all redux nodes until it finds one with the matching ID. As usual, it also creates a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/page-node-dependencies/\"\n  }), \"page dependency\"), \", from the query context\\u2019s path to the node ID.\"), mdx(\"p\", null, \"If the foreign key value is an array of IDs, then instead of returning a Field declaration for a single field, we return a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLUnionType\"), \", which is a union of all the distinct linked types in the array.\"), mdx(\"h4\", {\n    \"id\": \"plain-object-or-value-field\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#plain-object-or-value-field\",\n    \"aria-label\": \"plain object or value field permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Plain object or value field\"), mdx(\"p\", null, \"If the field was not handled as a mapping or foreign key reference, then it must be a normal every day field. E.g a scalar, string, or plain object. These cases are handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L38\"\n  }), \"inferGraphQLType\"), \".\"), mdx(\"p\", null, \"The core of this step creates a GraphQL Field object, where the type is inferred directly via the result of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof\"), \". E.g \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof(value) === 'boolean'\"), \" would result in type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLBoolean\"), \". Since these are simple values, resolvers are not defined (graphql-js takes care of that for us).\"), mdx(\"p\", null, \"If however, the value is an object or array, we recurse, using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L317\"\n  }), \"inferObjectStructureFromNodes\"), \" to create the GraphQL fields.\"), mdx(\"p\", null, \"In addition, Gatsby creates custom GraphQL types for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/types/type-file.js\"\n  }), \"types/type-file.js\"), \") and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date\"), \" (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/types/type-file.js\"\n  }), \"types/type-date.js\"), \"). If the value of our field is a string that looks like a filename or a date (handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-type.js#L52\"\n  }), \"should-infer\"), \" functions), then we return the appropriate custom type.\"), mdx(\"h3\", {\n    \"id\": \"childparent-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#childparent-fields\",\n    \"aria-label\": \"childparent fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Child/Parent fields\"), mdx(\"h4\", {\n    \"id\": \"child-fields-creation\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#child-fields-creation\",\n    \"aria-label\": \"child fields creation permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Child fields creation\"), mdx(\"p\", null, \"Let\\u2019s continue with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" type example. There are many transformer plugins that implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCreateNode\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" nodes. These produce \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" children that are of their own type. E.g \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"postsJson\"), \".\"), mdx(\"p\", null, \"Gatsby stores these children in redux as IDs in the parent\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" field. And then stores those child nodes as full redux nodes themselves (see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-creation/#node-relationship-storage-model\"\n  }), \"Node Creation\"), \" for more). E.g for a File node with two children, it will be stored in the redux \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodes\"), \" namespace as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  `id1`: { type: `File`, children: [`id2`, `id3`], ...other_fields },\\n  `id2`: { type: `markdownRemark`, ...other_fields },\\n  `id3`: { type: `postsJson`, ...other_fields }\\n}\\n\")), mdx(\"p\", null, \"An important note here is that we do not store a distinct collection of each type of child. Rather we store a single collection that they\\u2019re all packed into. The benefit of this is that we can easily create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File.children\"), \" field that returns all children, regardless of type. The downside is that the creation of fields such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File.childMarkdownRemark\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File.childrenPostsJson\"), \" is more complicated. This is what \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L48\"\n  }), \"createNodeFields\"), \" does.\"), mdx(\"p\", null, \"Another convenience Gatsby provides is the ability to query a node\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"child\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \", depending on whether a parent node has 1 or more children of that type.\"), mdx(\"h4\", {\n    \"id\": \"child-resolvers\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#child-resolvers\",\n    \"aria-label\": \"child resolvers permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"child resolvers\"), mdx(\"p\", null, \"When defining our parent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" gqlType, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L48\"\n  }), \"createNodeFields\"), \" will iterate over the distinct types of its children, and create their fields. Let\\u2019s say one of these child types is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \". Let\\u2019s assume there is only one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \" child per \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \". Therefore, its field name is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"childMarkdownRemark\"), \". Now, we must create its graphql Resolver.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"resolve(node, args, context, info)\\n\")), mdx(\"p\", null, \"The resolve function will be called when we are running queries for our pages. A query might look like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  file( relativePath { eq: \\\"blog/my-blog.md\\\" } ) {\\n    childMarkdownRemark { html }\\n  }\\n}\\n\")), mdx(\"p\", null, \"To resolve \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"file.childMarkdownRemark\"), \", we take the node we\\u2019re resolving, and filter over all of its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" until we find one of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \", which is returned. Remember that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" is a collection of IDs. So as part of this, we lookup the node by ID in redux too.\"), mdx(\"p\", null, \"But before we return from the resolve function, remember that we might be running this query within the context of a page. If that\\u2019s the case, then whenever the node changes, the page will need to be rerendered. To record that fact, we call \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/page-node-dependencies/\"\n  }), \"createPageDependency\"), \" with the node ID and the page, which is a field in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" object in the resolve function signature.\"), mdx(\"h4\", {\n    \"id\": \"parent-field\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#parent-field\",\n    \"aria-label\": \"parent field permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"parent field\"), mdx(\"p\", null, \"When a node is created as a child of some node (parent), that fact is stored in the child\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent\"), \" field. The value of which is the ID of the parent. The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L57\"\n  }), \"GraphQL resolver\"), \" for this field looks up the parent by that ID in redux and returns it. It also creates a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/page-node-dependencies/\"\n  }), \"page dependency\"), \", to record that the page being queried depends on the parent node.\"), mdx(\"h3\", {\n    \"id\": \"plugin-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#plugin-fields\",\n    \"aria-label\": \"plugin fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Plugin fields\"), mdx(\"p\", null, \"These are fields created by plugins that implement the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#setFieldsOnGraphQLNodeType\"\n  }), \"setFieldsOnGraphQLNodeType\"), \" API. These plugins return full GraphQL Field declarations, complete with type and resolve functions.\"), mdx(\"h3\", {\n    \"id\": \"file-types\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#file-types\",\n    \"aria-label\": \"file types permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"File types\"), mdx(\"p\", null, \"As described in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#plain-object-or-value-field\"\n  }), \"plain object or value field\"), \", if a string field value looks like a file path, then we infer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" as the field\\u2019s type. The creation of this type occurs in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/types/type-file.js#L18\"\n  }), \"type-file.js setFileNodeRootType()\"), \". It is called just after we have created the GqlType for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" (only called once).\"), mdx(\"p\", null, \"It creates a new GraphQL Field Config whose type is the just created \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" GqlType, and whose resolver converts a string into a File object. Here\\u2019s how it works:\"), mdx(\"p\", null, \"Say we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data/posts.json\"), \" file that has been sourced (of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \"), and then the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/packages/gatsby-transformer-json\"\n  }), \"gatsby-transformer-json\"), \" transformer creates a child node (of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PostsJson\"), \")\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript:title=data/posts.json\"\n  }), \";[\\n  {\\n    id: \\\"1685001452849004065\\\",\\n    text: \\\"Venice is \\uD83D\\uDC4C\\\",\\n    image: \\\"images/BdiU-TTFP4h.jpg\\\",\\n  },\\n]\\n\")), mdx(\"p\", null, \"Notice that the image value looks like a file. Therefore, we\\u2019d like to query it as if it were a file, and get its relativePath, accessTime, etc.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  postsJson(id: { eq: \\\"1685001452849004065\\\" }) {\\n    image {\\n      relativePath\\n      accessTime\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/types/type-file.js#L135\"\n  }), \"File type resolver\"), \" takes care of this. It gets the value (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"images/BdiU-TTFP4h.jpg\"), \"). It then looks up this node\\u2019s root NodeID via \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-tracking/\"\n  }), \"Node Tracking\"), \" which returns the original \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data/posts.json\"), \" file. It creates a new filename by concatenating the field value onto the parent node\\u2019s directory.\"), mdx(\"p\", null, \"I.e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" + \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"images/BdiU-TTFP4h.jpg\"), \" = \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data/images/BdiU-TTFP4h.jpg\"), \".\"), mdx(\"p\", null, \"And then finally it searches redux for the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" node whose path matches this one. This is our proper resolved node. We\\u2019re done!\"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "This documentation isn't up to date with latest\n schema customization changes . Help Gatsby by\nmaking a PR to  update this documentationâ€¦",
        "timeToRead": 6,
        "tableOfContents": {
          "items": [
            {
              "url": "#graphql-types-for-each-type-of-node",
              "title": "GraphQL Types for each type of node",
              "items": [
                {
                  "items": [
                    {
                      "url": "#fields-on-the-created-node-object-eg",
                      "title": "Fields on the created node object. E.g"
                    },
                    {
                      "url": "#childparent-eg",
                      "title": "Child/Parent. E.g:"
                    },
                    {
                      "url": "#fields-created-by-setfieldsongraphqlnodetype",
                      "title": "fields created by setFieldsOnGraphQLNodeType"
                    }
                  ]
                }
              ]
            },
            {
              "url": "#gqltype-creation",
              "title": "gqlType Creation",
              "items": [
                {
                  "url": "#fields-on-the-created-node-object",
                  "title": "Fields on the created node object",
                  "items": [
                    {
                      "url": "#mapping-field",
                      "title": "Mapping field"
                    },
                    {
                      "url": "#foreign-key-reference-___node",
                      "title": "Foreign Key reference (___NODE)"
                    },
                    {
                      "url": "#plain-object-or-value-field",
                      "title": "Plain object or value field"
                    }
                  ]
                },
                {
                  "url": "#childparent-fields",
                  "title": "Child/Parent fields",
                  "items": [
                    {
                      "url": "#child-fields-creation",
                      "title": "Child fields creation"
                    },
                    {
                      "url": "#child-resolvers",
                      "title": "child resolvers"
                    },
                    {
                      "url": "#parent-field",
                      "title": "parent field"
                    }
                  ]
                },
                {
                  "url": "#plugin-fields",
                  "title": "Plugin fields"
                },
                {
                  "url": "#file-types",
                  "title": "File types"
                }
              ]
            }
          ]
        },
        "fields": {
          "slug": "/docs/schema-gql-type/",
          "anchor": "schema-gql-type"
        },
        "frontmatter": {
          "title": "GraphQL Node Types Creation",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/schema-gql-type.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/schema-gql-type/",
      "prev": {
        "title": "Schema Generation",
        "link": "/docs/schema-generation/"
      },
      "next": {
        "title": "Building the Input Filters",
        "link": "/docs/schema-input-gql/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}