{
  "path": "/docs/debugging-async-lifecycles/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Debugging Asynchronous Lifecycle Methods\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Various lifecycle methods (see: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/\"\n  }), \"Gatsby Node APIs\"), \") within Gatsby are presumed to be asynchronous. In other words, these methods can \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"eventually\"), \" resolve to a value and this value is a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Promise\")), \". We wait for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" to resolve, and then mark the lifecycle method as completed when it does.\"), mdx(\"p\", null, \"In the context of Gatsby, this means that if you are invoking asynchronous functionality (e.g. data requests, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql\"), \" calls, etc.) and not correctly returning the Promise an internal issue can arise where the result of those call(s) happens \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the lifecycle method has already been marked as completed. Let\\u2019s consider an example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createPages = async function({ actions, graphql }) {\\n  // highlight-start\\n  graphql(`\\n    {\\n      allMarkdownRemark {\\n        edges {\\n          node {\\n            fields {\\n              slug\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `).then(res => {\\n    res.data.allMarkdownRemark.edges.forEach(edge => {\\n      const slug = edge.node.fields.slug\\n      actions.createPage({\\n        path: slug,\\n        component: require.resolve(`./src/templates/post.js`),\\n        context: { slug },\\n      })\\n    })\\n  })\\n  // highlight-end\\n}\\n\")), mdx(\"p\", null, \"Can you spot the error? In this case, an asynchronous action (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql\"), \") was invoked but this asynchronous action was neither \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \"ed nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \"ed from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createPages\"), \". This means that the lifecycle method will be marked as complete before it\\u2019s actually completed\\u2014which leads to missing data errors and other hard-to-debug errors.\"), mdx(\"p\", null, \"The fix is surprisingly simple\\u2014just one line to change!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createPages = async function({ actions, graphql }) {\\n  // highlight-next-line\\n  await graphql(`\\n    {\\n      allMarkdownRemark {\\n        edges {\\n          node {\\n            fields {\\n              slug\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `).then(res => {\\n    res.data.allMarkdownRemark.edges.forEach(edge => {\\n      const slug = edge.node.fields.slug\\n      actions.createPage({\\n        path: slug,\\n        component: require.resolve(`./src/templates/post.js`),\\n        context: { slug },\\n      })\\n    })\\n  })\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"best-practices\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#best-practices\",\n    \"aria-label\": \"best practices permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Best Practices\"), mdx(\"h3\", {\n    \"id\": \"use-async--await\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#use-async--await\",\n    \"aria-label\": \"use async  await permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Use \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"async\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"await\")), mdx(\"p\", null, \"With Node 8, Node is able to natively interpret \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" functions. This lets you write asynchronous code as if it were synchronous! This can clean up code that previously was using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" chain and tends to be a little simpler to understand!\"), mdx(\"h3\", {\n    \"id\": \"use-promiseall-if-necessary\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#use-promiseall-if-necessary\",\n    \"aria-label\": \"use promiseall if necessary permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Use \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"Promise.all\"), \" if necessary\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Promise.all\")), \" wraps up \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"multiple\"), \" asynchronous actions and resolves when \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"each\"), \" have completed. This can be especially helpful if you\\u2019re pulling from multiple data sources or abstracted some code that returns a Promise into a helper. For instance, consider the following code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"const fetch = require(\\\"node-fetch\\\")\\n\\nconst getJSON = uri => fetch(uri).then(response => response.json())\\n\\nexports.createPages = async function({ actions, graphql }) {\\n  // highlight-start\\n  const [pokemonData, rickAndMortyData] = await Promise.all([\\n    getJSON(\\\"https://some-rest-api.com/pokemon\\\"),\\n    getJSON(\\\"https://some-rest-api.com/rick-and-morty\\\"),\\n  ])\\n  // highlight-end\\n\\n  // use data to create pages with actions.createPage\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "Various lifecycle methods (see:  Gatsby Node APIs ) within Gatsby are presumed to be asynchronous. In other words, these methods canâ€¦",
        "timeToRead": 1,
        "tableOfContents": {
          "items": [
            {
              "url": "#best-practices",
              "title": "Best Practices",
              "items": [
                {
                  "url": "#use-async--await",
                  "title": "Use async / await"
                },
                {
                  "url": "#use-promiseall-if-necessary",
                  "title": "Use Promise.all if necessary"
                }
              ]
            }
          ]
        },
        "fields": {
          "slug": "/docs/debugging-async-lifecycles/",
          "anchor": "debugging-async-lifecycles"
        },
        "frontmatter": {
          "title": "Debugging Asynchronous Lifecycle Methods",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/debugging-async-lifecycles.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/debugging-async-lifecycles/",
      "prev": {
        "title": "Tracing Gatsby Builds",
        "link": "/docs/performance-tracing/"
      },
      "next": {
        "title": "Adding Website Functionality",
        "link": "/docs/adding-website-functionality/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}