{
  "path": "/blog/2019-03-04-new-schema-customization/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"New schema customization API in Gatsby\",\n  \"date\": \"2019-03-04T00:00:00.000Z\",\n  \"author\": \"Mikhail Novikov\",\n  \"tags\": [\"graphql\", \"releases\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today we are releasing a preview of a new core Gatsby API - Schema Customization. It gives Gatsby users much better control over the inferred schema, solving many common issues that people have had with their data sources. In addition to adding the new API, we rewrote big chunks of schema generation code from scratch. This gives us a great long-term foundation that will let us make Gatsby GraphQL better in the future.\"), mdx(\"p\", null, \"I would like to thank our community member \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/stefanprobst\"\n  }), \"Stefan Probst\"), \", who not only did lots of initial groundwork on the refactoring, but also helped immensely with the follow-up work there. We are really happy to have such a great community and super grateful to Stefan for all his hard work. I\\u2019d also like to thank \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/nodkz/\"\n  }), \"Pavel Chertorogov\"), \", the author of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql-compose.github.io/\"\n  }), \"graphql-compose\"), \" library that we used, who\\u2019s been super responsive to our bug reports and feature requests.\"), mdx(\"p\", null, \"As it\\u2019s a huge feature and big parts of the code are affected, we are releasing it as an alpha preview. You can try it by adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby@schema-customization\"), \" as a dependency for your Gatsby site.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install gatsby@schema-customization\\n\")), mdx(\"p\", null, \"We would really appreciate your help in surfacing any bugs in this code, so we encourage you to try it and report any issues that you encounter in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/12272\"\n  }), \"this pinned issue\"), \". If you want to contribute to fixing some of those bugs, open PRs against \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/pull/11480\"\n  }), \"this branch\"), \".\"), mdx(\"h1\", {\n    \"id\": \"why-was-it-needed\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#why-was-it-needed\",\n    \"aria-label\": \"why was it needed permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Why was it needed?\"), mdx(\"p\", null, \"The motivation to do this change is a two-fold one. Before this feature, Gatsby automatically generated a GraphQL schema for your site based on the data available from your source plugins. While this schema inference is great for getting started it has also been the cause of many problems.\"), mdx(\"p\", null, \"Automatically generating schemas mean that changing your data can result in a changed schema. An updated schema may no longer work with the queries you\\u2019ve written, resulting in errors and confusion. Making schema generation smarter is just pouring more oil on an already burning fire. The core issue is not the inference, but lack of control. Therefore we wanted to give people control over the schema.\"), mdx(\"p\", null, \"On the other hand, we wanted to reevaluate our approach to schemas in general. In the \\u201Cwild\\u201D, GraphQL is used very differently than in Gatsby. Schemas aren\\u2019t as commonly generated from the data sources and often schemas are the source of truth. We want to experiment with enabling people to use that approach with Gatsby too. By allowing people to define types and resolvers, we open new opportunities in that direction. We want to see how the community reacts to these changes and if that will evolve into new approaches to defining schemas in Gatsby.\"), mdx(\"h1\", {\n    \"id\": \"new-api\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#new-api\",\n    \"aria-label\": \"new api permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"New API\"), mdx(\"p\", null, \"There are two main additions to the API:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"createTypes\"), \" action that allows one to add, extend or fix the types by passing their type definition using \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://graphql.org/learn/schema/\"\n  }), \"Graphql SDL\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"createResolvers\"), \" \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/node-apis/\"\n  }), \"Gatsby Node API\"), \" that can add or override resolvers on any types and fields in the schema. It can also add new fields with such resolvers.\")), mdx(\"p\", null, \"Why the two APIs? \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" primary purpose is to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fix\"), \" the definition for an automatically generated Node type. Often one is totally happy with the default resolvers that Gatsby provides and the only issue is that inference can change based on data changes.\"), mdx(\"p\", null, \"On the other hand, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" is to add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"extra functionality\"), \" to types. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" also allows adding new \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"root fields\"), \" to Query type.\"), mdx(\"h2\", {\n    \"id\": \"createtypes\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#createtypes\",\n    \"aria-label\": \"createtypes permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"createTypes\")), mdx(\"p\", null, \"Let\\u2019s consider an example with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \", where we are loading data from an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authors.json\"), \" file. It has the following contents:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json:title=authors.json\"\n  }), \"[\\n  {\\n    \\\"name\\\": \\\"Mikhail Novikov\\\",\\n    \\\"birthday\\\": \\\"1987-09-25\\\"\\n  }\\n]\\n\")), mdx(\"p\", null, \"This would be inferred in Gatsby as a Node type with a Date type for birthday.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type AuthorsJson implements Node {\\n  # default gatsby node fields\\n  id: ID!\\n  parent: Node\\n  children: [Node!]!\\n  internal: `Internal`,\\n  # inferred fields\\n  name: String\\n  birthday: Date\\n}\\n\")), mdx(\"p\", null, \"However this can break if we accidentally add an invalid date as a birthday for a new node.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json:title=authors.json\"\n  }), \"[\\n  {\\n    \\\"name\\\": \\\"Mikhail Novikov\\\",\\n    \\\"birthday\\\": \\\"1987-09-25\\\"\\n  },\\n  {\\n    \\\"name\\\": \\\"Stefan Probst\\\",\\n    \\\"birthday\\\": \\\"Unknown\\\"\\n  }\\n]\\n\")), mdx(\"p\", null, \"Now there is a type conflict between date and string and this will be inferred as string, possibly breaking our queries.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type AuthorsJson implements Node {\\n  # default gatsby node fields\\n  id: ID!\\n  parent: Node\\n  children: [Node!]!\\n  internal: `Internal!`,\\n  # inferred fields\\n  name: String\\n  birthday: String\\n}\\n\")), mdx(\"p\", null, \"Luckily, now we can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" action to force birthday to be a Date.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"exports.sourceNodes = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    # One must say that the type is a Node\\n    type AuthorJson implements Node {\\n      # However Node fields are optional and you don't have to add them\\n      name: String\\n      birthday: Date\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"Gatsby will now know that you want a Date and not override it with a string.\"), mdx(\"p\", null, \"You can specify types for some or all of the fields that you have on the given node type. Gatsby will add missing fields. This behaviour can be controlled with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@infer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@dontInfer\"), \" directives.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"# For this type `name` won't be added\\ntype AuthorJson implements Node @dontInfer {\\n  birthday: Date\\n}\\n\\n# For this type `name` won't be added but `birthday` won't get a Gatsby resolver for date formatting\\ntype AuthorJson implements Node @dontInfer(noDefaultResolvers: true) {\\n  birthday: Date\\n}\\n\\n# For this type both `name` and `birthday` fields will be added. Current default behaviour, but allows one to be explicit about it.\\ntype AuthorJson implements Node @infer {\\n  id: ID!\\n}\\n\\n# `birthday` will be Date, but we won't add a Gatsby resolver for date formatting\\ntype AuthorJson implements Node @infer(noDefaultResolvers: true) {\\n  id: ID!\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"createresolvers\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#createresolvers\",\n    \"aria-label\": \"createresolvers permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"createResolvers\")), mdx(\"p\", null, \"This is a similar API to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFieldsOnGraphQLNodeType\"), \" in that it allows you to add new fields and resolvers to types. However, this one is run last, so you\\u2019d have the entire schema available to be augmented. It is also possible to extend the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" type to add custom root resolvers, which enables a powerful resolver-based approach to querying your data sources. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" is called after third-party schemas are merged (e.g. ones added by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-graphql\"), \"), so you can extend those schemas too.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers, schema }) => {\\n  createResolvers({\\n    AuthorJson: {\\n      // Modify birthday resolver so that it uses 1970-01-01 as default date\\n      birthday: {\\n        resolve(source, args, context, info) {\\n          // original resolver available as \\\"info.originalResolver\\\"\\n          if (Number.isNaN(new Date(source[\\\"birthday\\\"]))) {\\n            return info.originalResolver(\\n              {\\n                ...source,\\n                birthday: \\\"1970-01-01\\\",\\n              },\\n              args,\\n              context,\\n              info\\n            )\\n          } else {\\n            return info.originalResolver(source, args, context, info)\\n          }\\n        },\\n      },\\n    },\\n  })\\n}\\n\")), mdx(\"p\", null, \"It\\u2019s also possible to create new root fields, for example one that will return all author names as strings.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"createResolvers({\\n  Query: {\\n    allAuthorFullNames: {\\n      type: `[String!]!`,\\n      resolve(source, args, context, info) {\\n        const authors = context.nodeModel.getAllNodes({\\n          type: `AuthorJson`,\\n        })\\n        return authors.map(author => author.name)\\n      },\\n    },\\n  },\\n})\\n\")), mdx(\"p\", null, \"Notice the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context.nodeModel\"), \". We expose our internal node storage to the resolvers, so that one can fetch data from there. In addition to lower level access functions (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getNodeById\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getAllNodes\"), \"), full node querying is available in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runQuery\"), \".\"), mdx(\"p\", null, \"You can also see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions\"\n  }), \"using-type-definitions example\"), \" in the Gatsby repository.\"), mdx(\"h1\", {\n    \"id\": \"other-niceties\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#other-niceties\",\n    \"aria-label\": \"other niceties permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Other niceties\"), mdx(\"p\", null, \"Refactoring the schema generation allowed us to fix some related long-standing bugs and issues.\"), mdx(\"h3\", {\n    \"id\": \"type-names\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#type-names\",\n    \"aria-label\": \"type names permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Type Names\"), mdx(\"p\", null, \"Previously, type names were generated with names like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal_2\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SomeType_2\"), \", which can be extremely confusing. We\\u2019ve normalized all the names, so that these additional suffixes are no longer necessary. If you have relied on generated names as above, this branch will break for you. However, we never considered these types to be part our public API, partially because of the above issue. By making this change we can now assert that the naming of the types should be stable.\"), mdx(\"h3\", {\n    \"id\": \"connection-nodes-field\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#connection-nodes-field\",\n    \"aria-label\": \"connection nodes field permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Connection \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"nodes\"), \" field\"), mdx(\"p\", null, \"Querying connections is pretty verbose in Gatsby.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  allMarkdownRemark {\\n    edges {\\n      node {\\n        id\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"When you have many connections, this becomes pretty tedious, especially destructuring it all in JS. We\\u2019ve added a very common shortcut \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodes\"), \" that allows you to not write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{ edges { node }}\"), \", but directly resolves an array of nodes instead.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  allMarkdownRemark {\\n    nodes {\\n      id\\n    }\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"inference-quirks\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#inference-quirks\",\n    \"aria-label\": \"inference quirks permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Inference quirks\"), mdx(\"p\", null, \"We\\u2019ve had some quirks in inference that were dependant on ordering. We\\u2019ve made all inference deterministic.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Mix of date and non-date strings is always a string\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Conflicting field names always prefer Node references first and then the canonical name of the field.\")), mdx(\"h1\", {\n    \"id\": \"how-did-we-do-it\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#how-did-we-do-it\",\n    \"aria-label\": \"how did we do it permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"How did we do it?\"), mdx(\"p\", null, \"The biggest issue with building GraphQL schemas with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" expects all types to be final at the moment where either the schema is created or one inspects the fields of the type. This is solved in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" by using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"thunks\"), \", non-argument functions that refer to types in some global context. With hand-written schemas usually there are type definitions in the same file as the newly defined type, but this isn\\u2019t available in a generated schema situation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Foo = graphql.GraphQLObjectType({\\n  name: \\\"Foo\\\",\\n  fields: () => ({\\n    id: {\\n      type: new graphql.GraphQLNonNull(graphql.GraphQLID),\\n    },\\n    bar: {\\n      // Must be an actual reference to that type\\n      type: Bar,\\n    },\\n  }),\\n})\\n\")), mdx(\"p\", null, \"To solve these issues, a pattern called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Type Registry\"), \" has been widely used. A type registry is an abstraction that holds types inside it and allows other types to retrieve them.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// some global state type registry\\nconst TypeRegistry = require(\\\"./typeRegistry\\\")\\n\\nconst Foo = graphql.GraphQLObjectType({\\n  name: \\\"Foo\\\",\\n  fields: () => ({\\n    id: {\\n      type: new graphql.GraphQLNonNull(graphql.GraphQLID),\\n    },\\n    bar: {\\n      // Allows referring to types by their string names\\n      type: TypeRegistry.getType(\\\"Bar\\\"),\\n    },\\n  }),\\n})\\n\")), mdx(\"p\", null, \"After all types are collected into the type registry, the registry can be converted to a normal GraphQL schema. Other common features include being able to generate types like input objects and filter from the types held in the type registry.\"), mdx(\"p\", null, \"We didn\\u2019t want to implement a type registry and all the related parts ourselves. Thankfully, there is a library just for that - \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql-compose.github.io/\"\n  }), \"graphql-compose\"), \". We opted to use it and it saved us lots of time. I really recommend this library to anyone, especially if you plan to generate types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// global schema composer\\nconst { SchemaComposer } = require(\\\"graphql-compose\\\")\\n\\nconst Foo = SchemaComposer.TypeComposer.create(({\\n  name: \\\"Foo\\\",\\n  fields: () => ({\\n    id: {\\n      // types can be strings\\n      type: 'ID!'\\n    },\\n    bar: {\\n      // Allows referring to types by their string names\\n      type: 'Bar'\\n    },\\n  }),\\n})\\n\")), mdx(\"p\", null, \"The final schema pipeline that we implemented works like this:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We collect all types that are created with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"createTypes\"), \" and add them to the compose type registry (called \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Schema Composer\"), \")\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We go through all the collected nodes and we infer types for them\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We merge user defined types with inferred types and add them to the composer\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We add default resolvers for type fields, such as for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"File\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Date\"), \" fields\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setFieldsOnNodeType\"), \" is called and those fields are added to the types\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We create derived input objects, such as filter and sort and then create pagination types such as Connections\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Root level resolvers are created for all node types\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Third-party schemas are merged into the Gatsby schema\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"createResolvers\"), \" API is called and resulting resolvers are added to the schema\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We generate the schema\")), mdx(\"p\", null, \"You can see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"packages/gatsby/schema/\"), \" folder in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/pull/11480\"\n  }), \"schema refactoring PR\"), \" to learn more about the code.\"), mdx(\"h1\", {\n    \"id\": \"further-work\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#further-work\",\n    \"aria-label\": \"further work permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Further work\"), mdx(\"p\", null, \"These schema changes are a first step. In the future we want to add more control over the schema and more access to our internal APIs to our users. Our next step would be to add explicit types to the plugins that we maintain. We also want to let those plugins expose their internal APIs through the Model layer, like we did for our root Node API. This way one can reuse the functionality that is only available in plugins in their own resolvers.\"), mdx(\"p\", null, \"We are super excited about those changes. As I mentioned, we really encourage you to try it by adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby@schema-customization\"), \" as a dependency to your Gatsby application. Send us feedback in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/12272\"\n  }), \"this issue\"), \". We can\\u2019t wait to hear your feedback on this new, core functionality and see all the great apps and functionality it allows you to build.\"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "Today we are releasing a preview of a new core Gatsby API - Schema Customization. It gives Gatsby users much better control over the…",
        "timeToRead": 6,
        "fields": {
          "slug": "/blog/2019-03-04-new-schema-customization/",
          "publishedAt": null
        },
        "frontmatter": {
          "title": "New schema customization API in Gatsby",
          "excerpt": null,
          "date": "March 4th 2019",
          "rawDate": "2019-03-04T00:00:00.000Z",
          "canonicalLink": null,
          "tags": [
            "graphql",
            "releases"
          ],
          "image": null,
          "imageAuthor": null,
          "imageAuthorLink": null,
          "imageTitle": null,
          "showImageInArticle": null,
          "author": {
            "id": "Mikhail Novikov",
            "bio": "GraphQL sommelier. Did Reindex, GraphQL Delegation, Schema Stitching, Launchpad. Organizer @GraphQLFinland.",
            "twitter": "@freiksenet",
            "avatar": {
              "childImageSharp": {
                "fixed": {
                  "tracedSVG": "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%3e%3crect%20width='100%25'%20height='100%25'%20fill='%23f6f2f8'/%3e%3cpath%20d='M12%209v8l2%204%201%203%201%203-1%203h5c6%200%207%200%205-5v-6c0-2-4-3-4-1l-3%201c-2%200-3-7-2-9l1-2c-2-2-4-1-5%201'%20fill='%23e0d6eb'%20fill-rule='evenodd'/%3e%3c/svg%3e",
                  "width": 64,
                  "height": 64,
                  "src": "/static/5429bb44f659c90adf5ad9756da87eaa/88ae8/freiksenet.jpg",
                  "srcSet": "/static/5429bb44f659c90adf5ad9756da87eaa/88ae8/freiksenet.jpg 1x,\n/static/5429bb44f659c90adf5ad9756da87eaa/0740f/freiksenet.jpg 1.5x,\n/static/5429bb44f659c90adf5ad9756da87eaa/c9264/freiksenet.jpg 2x"
                }
              }
            },
            "fields": {
              "slug": "/contributors/mikhail-novikov/"
            }
          }
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/blog/2019-03-04-new-schema-customization/",
      "prev": {
        "fields": {
          "slug": "/blog/2019-03-01-localization-with-gatsby-and-sanity/",
          "package": null,
          "released": true
        },
        "frontmatter": {
          "title": "A method for Localization with Gatsby and Sanity.io",
          "draft": null,
          "canonicalLink": null,
          "publishedAt": null,
          "issue": null,
          "tags": [
            "sanity",
            "i18n"
          ]
        }
      },
      "next": {
        "fields": {
          "slug": "/blog/2019-03-05-dot-org-messaging-survey/",
          "package": null,
          "released": true
        },
        "frontmatter": {
          "title": "Results from .org messaging survey are in",
          "draft": null,
          "canonicalLink": null,
          "publishedAt": null,
          "issue": null,
          "tags": [
            "ux",
            "user-testing",
            "cutting-edge-experiences"
          ]
        }
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateBlogPostJs2991924798(\n  $slug: String!\n) {\n  mdx(fields: {slug: {eq: $slug}}) {\n    body\n    excerpt\n    timeToRead\n    fields {\n      slug\n      publishedAt\n    }\n    frontmatter {\n      title\n      excerpt\n      date(formatString: \"MMMM Do YYYY\")\n      rawDate: date\n      canonicalLink\n      tags\n      image {\n        childImageSharp {\n          resize(width: 1500, height: 1500) {\n            src\n          }\n          fluid(maxWidth: 786) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n      imageAuthor\n      imageAuthorLink\n      imageTitle\n      showImageInArticle\n      author {\n        id\n        bio\n        twitter\n        avatar {\n          childImageSharp {\n            fixed(width: 64, height: 64, quality: 75, traceSVG: {turdSize: 10, background: \"#f6f2f8\", color: \"#e0d6eb\"}) {\n              ...GatsbyImageSharpFixed_tracedSVG\n            }\n          }\n        }\n        fields {\n          slug\n        }\n      }\n    }\n  }\n}\n\nfragment GatsbyImageSharpFluid on ImageSharpFluid {\n  base64\n  aspectRatio\n  src\n  srcSet\n  sizes\n}\n\nfragment GatsbyImageSharpFixed_tracedSVG on ImageSharpFixed {\n  tracedSVG\n  width\n  height\n  src\n  srcSet\n}\n"
}