{
  "path": "/docs/schema-input-gql/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Inferring Input Filters\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This documentation isn\\u2019t up to date with latest\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-customization\"\n  }), \"schema customization changes\"), \". Help Gatsby by\\nmaking a PR to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/14228\"\n  }), \"update this documentation\"), \"!\")), mdx(\"h2\", {\n    \"id\": \"input-filters-vs-gqltype\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#input-filters-vs-gqltype\",\n    \"aria-label\": \"input filters vs gqltype permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Input Filters vs gqlType\"), mdx(\"p\", null, \"In \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-gql-type\"\n  }), \"gqlTypes\"), \", we inferred a Gatsby Node\\u2019s main fields. These allow us to query a node\\u2019s children, parent and object fields. But these are only useful once a top level GraphQL Query has returned results. In order to query by those fields, we must create GraphQL objects for input filters. E.g, querying for all markdownRemark nodes that have 4 paragraphs.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  markdownRemark(wordCount: { paragraphs: { eq: 4 } }) {\\n    html\\n  }\\n}\\n\")), mdx(\"p\", null, \"The arguments (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wordcount: {paragraphs: {eq: 4}}\"), \") to the query are known as Input filters. In graphql-js, they are the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/graphql-js/type/#graphqlinputobjecttype\"\n  }), \"GraphQLInputObjectType\"), \". This section covers how these Input filters are inferred.\"), mdx(\"h3\", {\n    \"id\": \"inferring-input-filters-from-example-node-values\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#inferring-input-filters-from-example-node-values\",\n    \"aria-label\": \"inferring input filters from example node values permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Inferring input filters from example node values\"), mdx(\"p\", null, \"The first step is to generate an input field for each type of field on the redux nodes. For example, we might want to query markdown nodes by their front matter author:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  markdownRemark(frontmatter: { author: { eq: \\\"F. Scott Fitzgerald\\\" } }) {\\n    id\\n  }\\n}\\n\")), mdx(\"p\", null, \"This step is handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-input-fields.js#L235\"\n  }), \"inferInputObjectStrctureFromNodes\"), \". First, we generate an example Value (see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-gql-type#gqltype-creation\"\n  }), \"gqlTypes\"), \"). For each field on the example value (e.g \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author\"), \"), we create a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/graphql-js/type/#graphqlinputobjecttype\"\n  }), \"GraphQLInputObjectType\"), \" with an appropriate name. The fields for Input Objects are predicates that depend on the value\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof\"), \" result. E.g for a String, we need to be able to query by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"regex\"), \" etc. If the value is an object itself, then we recurse, building its fields as above.\"), mdx(\"p\", null, \"If the key is a foreign key reference (ends in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \"), then we find the field\\u2019s linked Type first, and progress as above (for more on how foreign keys are implemented, see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-gql-type#foreign-key-reference-___node\"\n  }), \"gqlType\"), \"). After this step, we will end up with an Input Object type such as .\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  `MarkdownRemarkFrontmatterAuthor`: {\\n    name: `MarkdownRemarkFrontmatterAuthorInputObject`,\\n    fields: {\\n      `MarkdownRemarkFrontmatterAuthorName` : {\\n        name: `MarkdownRemarkFrontmatterAuthorNameQueryString`,\\n        fields: {\\n          eq: { type: GraphQLString },\\n          ne: { type: GraphQLString },\\n          regex: { type: GraphQLString },\\n          glob: { type: GraphQLString },\\n          in: { type: new GraphQLList(GraphQLString) },\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"inferring-input-filters-from-plugin-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#inferring-input-filters-from-plugin-fields\",\n    \"aria-label\": \"inferring input filters from plugin fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Inferring input filters from plugin fields\"), mdx(\"p\", null, \"Plugins themselves have the opportunity to create custom fields that apply to ALL nodes of a particular type, as opposed to having to explicitly add the field on every node creation. An example would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \" which adds a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wordcount\"), \" field to each node automatically. This section deals with the generation of input filters so that we can query by these fields as well. E.g:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  markdownRemark(wordCount: { paragraphs: { eq: 4 } }) {\\n    html\\n  }\\n}\\n\")), mdx(\"p\", null, \"Plugins add custom fields by implementing the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#setFieldsOnGraphQLNodeType\"\n  }), \"setFieldsOnGraphQLNodeType\"), \" API. They must return a full GraphQLObjectType, complete with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \" function. Once this API has been run, the fields are passed to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-input-fields-from-fields.js#L195\"\n  }), \"inferInputObjectStructureFromFields\"), \", which will generate input filters for the new fields. The result would look something like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ //GraphQLInputObjectType\\n  name: `WordCountwordcountInputObject`,\\n  fields: {\\n    `paragraphs`: {\\n      type: { // GraphQLInputObjectType\\n        name: `WordCountParagraphsQueryInt`,\\n        fields: {\\n          eq: { type: GraphQLInt },\\n          ne: { type: GraphQLInt },\\n          gt: { type: GraphQLInt },\\n          gte: { type: GraphQLInt },\\n          lt: { type: GraphQLInt },\\n          lte: { type: GraphQLInt },\\n          in: { type: new GraphQLList(GraphQLInt) },\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"As usual, the input filter fields (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lt\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gt\"), \", etc) are based on the type of the field (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \" in this case), which is defined by the plugin.\"), mdx(\"h3\", {\n    \"id\": \"merged-result\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#merged-result\",\n    \"aria-label\": \"merged result permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Merged result\"), mdx(\"p\", null, \"Now that we\\u2019ve generated input fields from the redux nodes and from custom plugin fields, we merge them together. E.g\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n\\n  // from infer input fields from object\\n  `MarkdownRemarkAuthor`: {\\n    name: `MarkdownRemarkAuthorInputObject`,\\n    fields: {\\n      `MarkdownRemarkAuthorName` : {\\n        name: `MarkdownRemarkAuthorNameQueryString`,\\n        fields: {\\n          eq: { type: GraphQLString },\\n          ne: { type: GraphQLString },\\n          regex: { type: GraphQLString },\\n          glob: { type: GraphQLString },\\n          in: { type: new GraphQLList(GraphQLString) },\\n        }\\n      }\\n    }\\n  },\\n\\n  // From infer input fields from fields\\n  `wordCount`: { //GraphQLInputObjectType\\n    name: `WordCountwordcountInputObject`,\\n    fields: {\\n      `paragraphs`: {\\n        type: { // GraphQLInputObjectType\\n          name: `WordCountParagraphsQueryInt`,\\n          fields: {\\n            eq: { type: GraphQLInt },\\n            ne: { type: GraphQLInt },\\n            gt: { type: GraphQLInt },\\n            gte: { type: GraphQLInt },\\n            lt: { type: GraphQLInt },\\n            lte: { type: GraphQLInt },\\n            in: { type: new GraphQLList(GraphQLInt) },\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "This documentation isn't up to date with latest\n schema customization changes . Help Gatsby by\nmaking a PR to  update this documentation…",
        "timeToRead": 2,
        "tableOfContents": {
          "items": [
            {
              "url": "#input-filters-vs-gqltype",
              "title": "Input Filters vs gqlType",
              "items": [
                {
                  "url": "#inferring-input-filters-from-example-node-values",
                  "title": "Inferring input filters from example node values"
                },
                {
                  "url": "#inferring-input-filters-from-plugin-fields",
                  "title": "Inferring input filters from plugin fields"
                },
                {
                  "url": "#merged-result",
                  "title": "Merged result"
                }
              ]
            }
          ]
        },
        "fields": {
          "slug": "/docs/schema-input-gql/",
          "anchor": "schema-input-gql"
        },
        "frontmatter": {
          "title": "Inferring Input Filters",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/schema-input-gql.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/schema-input-gql/",
      "prev": {
        "title": "Building the GqlType",
        "link": "/docs/schema-gql-type/"
      },
      "next": {
        "title": "Querying with Sift",
        "link": "/docs/schema-sift/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}