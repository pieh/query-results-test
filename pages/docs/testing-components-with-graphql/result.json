{
  "path": "/docs/testing-components-with-graphql/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Testing components with GraphQL\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you try to run unit tests on components that use GraphQL queries, you will\\ndiscover that you have no data. Jest can\\u2019t run your queries, so if you are\\ntesting components that rely on GraphQL data, you will need to provide the data\\nyourself. This is a good thing, as otherwise your tests could break if your data\\nchanges, and in the case of remote data sources it would need network access to\\nrun tests.\"), mdx(\"p\", null, \"In general it is best practice to test the smallest components possible, so the\\nsimplest thing to do is to test the individual page components with mock data,\\nrather than trying to test a full page. However, if you do want to test the full\\npage you\\u2019ll need to provide the equivalent data to the component. Luckily\\nthere\\u2019s a simple way to get the data you need.\"), mdx(\"p\", null, \"First you should make sure you have read\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/unit-testing/\"\n  }), \"the unit testing guide\"), \" and set up your project as\\ndescribed. This guide is based on the same blog starter project. You will be\\nwriting a simple snapshot test for the index page.\"), mdx(\"p\", null, \"As Jest doesn\\u2019t run or compile away your GraphQL queries you need to mock the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql\"), \" function to stop it throwing an error. If you set your project up with\\na mock for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \" as described in the unit testing guide then this is already\\ndone.\"), mdx(\"h2\", {\n    \"id\": \"testing-page-queries\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#testing-page-queries\",\n    \"aria-label\": \"testing page queries permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Testing page queries\"), mdx(\"p\", null, \"As this is testing a page component you will need to put your tests in another\\nfolder so that Gatsby doesn\\u2019t try to turn the tests into pages.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=src/pages/__tests__/index.js\"\n  }), \"import React from \\\"react\\\"\\nimport renderer from \\\"react-test-renderer\\\"\\nimport Index from \\\"../index\\\"\\n\\ndescribe(\\\"Index\\\", () =>\\n  it(\\\"renders correctly\\\", () => {\\n    const tree = renderer.create(<Index />).toJSON()\\n    expect(tree).toMatchSnapshot()\\n  }))\\n\")), mdx(\"p\", null, \"If you run this test you will get an error, as the StaticQuery in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Layout\"), \" component is not mocked. You can fix this by mocking it, like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=src/__tests__/index.js\"\n  }), \"import React from \\\"react\\\"\\nimport renderer from \\\"react-test-renderer\\\"\\nimport { StaticQuery } from \\\"gatsby\\\"\\nimport Index from \\\"../pages/index\\\"\\n\\nbeforeEach(() => {\\n  StaticQuery.mockImplementationOnce(({ render }) =>\\n    render({\\n      site: {\\n        siteMetadata: {\\n          title: `Default Starter`,\\n        },\\n      },\\n    })\\n  )\\n})\\n\\ndescribe(\\\"Index\\\", () =>\\n  it(\\\"renders correctly\\\", () => {\\n    const tree = renderer.create(<Index />).toJSON()\\n    expect(tree).toMatchSnapshot()\\n  }))\\n\")), mdx(\"p\", null, \"This should fix the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StaticQuery\"), \" error, but in a more real-world example you may also be using a page query with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql\"), \" helper from Gatsby. In this case, there is no GraphQL data being passed to the component. We can pass this in too,\\nbut the structure is a little more complicated. Luckily there\\u2019s an easy way to\\nget some suitable data. Run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm run develop\"), \" and go to\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:8000/___graphql\"\n  }), \"http://localhost:8000/___graphql\"), \" to load the GraphiQL IDE. You can now get the\\nright data using the same query that you used on the page. If it is a simple\\nquery with no fragments you can copy it directly. That is the case here, run\\nthis query copied from the index page:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query IndexQuery {\\n  site {\\n    siteMetadata {\\n      author\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The output panel should now give you a nice JSON object with the query result.\\nHere it is, trimmed to one node for brevity:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"site\\\": {\\n      \\\"siteMetadata\\\": {\\n        \\\"author\\\": \\\"Your Name Here\\\"\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"GraphiQL doesn\\u2019t know about any fragments defined by Gatsby, so if your query\\nuses them then you\\u2019ll need to replace those with the content of the fragment. If\\nyou\\u2019re using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-sharp\"), \" you\\u2019ll find the fragments in\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-transformer-sharp/src/fragments.js\"\n  }), \"gatsby-transformer-sharp/src/fragments.js\"), \".\\nSo, for example if your query includes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"    image {\\n        childImageSharp {\\n            fluid(maxWidth: 1024) {\\n                ...GatsbyImageSharpFluid\\n            }\\n        }\\n    }\\n\")), mdx(\"p\", null, \"\\u2026it becomes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"    image {\\n        childImageSharp {\\n            fluid(maxWidth: 1024) {\\n                base64\\n                aspectRatio\\n                src\\n                srcSet\\n                sizes\\n            }\\n        }\\n    }\\n\")), mdx(\"p\", null, \"When you have the result, copy the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" value from the output panel. Good\\npractice is to store your fixtures in a separate file, but for simplicity here\\nyou will be defining it directly inside your test file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=src/pages/__tests__/index.js\"\n  }), \"import React from \\\"react\\\"\\nimport renderer from \\\"react-test-renderer\\\"\\nimport Index from \\\"../index\\\"\\n\\nbeforeEach(() => {\\n  StaticQuery.mockImplementationOnce(({ render }) =>\\n    render({\\n      site: {\\n        siteMetadata: {\\n          title: `Default Starter`,\\n        },\\n      },\\n    })\\n  )\\n})\\n\\ndescribe(\\\"Index\\\", () => {\\n  it(\\\"renders correctly\\\", () => {\\n    const data = {\\n      site: {\\n        siteMetadata: {\\n          author: \\\"Your name\\\",\\n        },\\n      },\\n    }\\n\\n    const tree = renderer.create(<Index data={data} />).toJSON()\\n    expect(tree).toMatchSnapshot()\\n  })\\n})\\n\")), mdx(\"p\", null, \"Run the tests and they should now pass. Take a look in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__snapshots__\"), \" to see\\nthe output.\"), mdx(\"h2\", {\n    \"id\": \"testing-staticquery\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#testing-staticquery\",\n    \"aria-label\": \"testing staticquery permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Testing StaticQuery\"), mdx(\"p\", null, \"The method above works for page queries, as you can pass the data in directly to\\nthe component. This doesn\\u2019t work for components that use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StaticQuery\"), \" though,\\nas that uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" rather than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" so we need to take a slightly\\ndifferent approach to testing these types of components.\"), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StaticQuery\"), \" allows you to make queries in any component, not just pages.\\nThis gives a lot of flexibility, and avoid having to pass the props down to\\ndeeply-nested components. The pattern for enabling type checking described in\\nthe docs is a good starting point for making these components testable, as it\\nseparates the query from the definition of the component itself. However that\\nexample doesn\\u2019t export the inner, pure component, which is what you\\u2019ll need to\\ntest.\"), mdx(\"p\", null, \"Here is the example of a header component that queries the page data itself,\\nrather than needing it to be passed from the layout:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx:title=src/components/header.js\"\n  }), \"import React from \\\"react\\\"\\nimport { StaticQuery } from \\\"gatsby\\\"\\n\\nconst Header = ({ data }) => (\\n  <header>\\n    <h1>{data.site.siteMetadata.title}</h1>\\n  </header>\\n)\\n\\nexport default props => (\\n  <StaticQuery\\n    query={graphql`\\n      query {\\n        site {\\n          siteMetadata {\\n            title\\n          }\\n        }\\n      }\\n    `}\\n    render={data => <Header {...props} data={data} />}\\n  />\\n)\\n\")), mdx(\"p\", null, \"This is almost ready: all you need to do is export the pure component that you\\nare passing to StaticQuery. Rename it first to avoid confusion:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx:title=src/components/header.js\"\n  }), \"import React from \\\"react\\\"\\nimport { StaticQuery, graphql } from \\\"gatsby\\\"\\n\\nexport const PureHeader = ({ data }) => (\\n  <header>\\n    <h1>{data.site.siteMetadata.title}</h1>\\n  </header>\\n)\\n\\nexport const Header = props => (\\n  <StaticQuery\\n    query={graphql`\\n      query {\\n        site {\\n          siteMetadata {\\n            title\\n          }\\n        }\\n      }\\n    `}\\n    render={data => <PureHeader {...props} data={data} />}\\n  />\\n)\\n\\nexport default Header\\n\")), mdx(\"p\", null, \"Now you have two components exported from the file: the component that includes\\nthe StaticQuery data which is still the default export, and another component\\nthat you can test. This means you can test the component independently of the\\nGraphQL.\"), mdx(\"p\", null, \"This is a good example of the benefits of keeping components \\u201Cpure\\u201D, meaning\\nthey always generate the same output if given the same inputs and have no\\nside-effects apart from their return value. This means we can be sure the tests\\nare always reproducible and don\\u2019t fail if, for example, the network is down or\\nthe data source changes. In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Header\"), \" is impure as it makes a\\nquery, so the output depends on something apart from its props. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PureHeader\"), \" is\\npure because its return value is entirely dependent on the props passed to it.\\nThis means it\\u2019s very easy to test, and a snapshot should never change.\"), mdx(\"p\", null, \"Here\\u2019s how:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=src/components/__tests__/header.js\"\n  }), \"import React from \\\"react\\\"\\nimport renderer from \\\"react-test-renderer\\\"\\n\\nimport { PureHeader as Header } from \\\"../header\\\"\\n\\ndescribe(\\\"Header\\\", () => {\\n  it(\\\"renders correctly\\\", () => {\\n    // Created using the query from Header.js\\n    const data = {\\n      site: {\\n        siteMetadata: {\\n          title: \\\"Gatsby Starter Blog\\\",\\n        },\\n      },\\n    }\\n    const tree = renderer.create(<Header data={data} />).toJSON()\\n    expect(tree).toMatchSnapshot()\\n  })\\n})\\n\")), mdx(\"h2\", {\n    \"id\": \"using-typescript\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#using-typescript\",\n    \"aria-label\": \"using typescript permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Using TypeScript\"), mdx(\"p\", null, \"If you are using TypeScript this is a lot easier to get right as the type errors\\nwill tell you exactly what you should be passing to the components. This is why\\nit is a good idea to define type interfaces for all of your GraphQL queries.\"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "If you try to run unit tests on components that use GraphQL queries, you will\ndiscover that you have no data. Jest can't run your queriesâ€¦",
        "timeToRead": 3,
        "tableOfContents": {
          "items": [
            {
              "url": "#testing-page-queries",
              "title": "Testing page queries"
            },
            {
              "url": "#testing-staticquery",
              "title": "Testing StaticQuery"
            },
            {
              "url": "#using-typescript",
              "title": "Using TypeScript"
            }
          ]
        },
        "fields": {
          "slug": "/docs/testing-components-with-graphql/",
          "anchor": "testing-components-with-graphql"
        },
        "frontmatter": {
          "title": "Testing components with GraphQL",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/testing-components-with-graphql.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/testing-components-with-graphql/",
      "prev": {
        "title": "Unit Testing",
        "link": "/docs/unit-testing/"
      },
      "next": {
        "title": "End-to-end Testing",
        "link": "/docs/end-to-end-testing/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}