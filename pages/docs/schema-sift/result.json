{
  "path": "/docs/schema-sift/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Querying with Sift\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This documentation isn\\u2019t up to date with latest\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-customization\"\n  }), \"schema customization changes\"), \". Help Gatsby by\\nmaking a PR to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/14228\"\n  }), \"update this documentation\"), \"!\")), mdx(\"h2\", {\n    \"id\": \"summary\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#summary\",\n    \"aria-label\": \"summary permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Summary\"), mdx(\"p\", null, \"Gatsby stores all data loaded during the source-nodes phase in Redux. And it allows you to write GraphQL queries to query that data. But Redux is a plain JavaScript object store. So how does Gatsby query over those nodes using the GraphQL query language?\"), mdx(\"p\", null, \"The answer is that it uses the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/crcn/sift.js/tree/master\"\n  }), \"sift.js\"), \" library. It is a port of the MongoDB query language that works over plain JavaScript objects. It turns out that mongo\\u2019s query language is very compatible with GraphQL.\"), mdx(\"p\", null, \"Most of the logic below is in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/redux/run-sift.js\"\n  }), \"run-sift.js\"), \" file, which is called from the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L191\"\n  }), \"ProcessedNodeType \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"resolve()\")), \" function.\"), mdx(\"h2\", {\n    \"id\": \"processednodetype-resolve-function\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#processednodetype-resolve-function\",\n    \"aria-label\": \"processednodetype resolve function permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"ProcessedNodeType Resolve Function\"), mdx(\"p\", null, \"Remember, at the point this resolve function is created, we have been iterating over all the distinct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node.internal.type\"), \"s in the redux \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodes\"), \" namespace. So for instance we might be on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" type. Therefore the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \" function closes over this type name and has access to all the nodes of that type.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \" function calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"run-sift.js\"), \", and provides it with the following arguments:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"GraphQLArgs (as JavaScript object). Within a filter. E.g \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"wordcount: { paragraphs: { eq: 4 } }\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All nodes in redux of this type. E.g where \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"internal.type == MmarkdownRemark'\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Context \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"path\"), \", if being called as part of a \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/query-execution/#query-queue-execution\"\n  }), \"page query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"typeName. E.g \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"markdownRemark\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"gqlType. See \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/schema-gql-type\"\n  }), \"more on gqlType\"))), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"runSift({\\n  args: {\\n    filter: { // Exact args from GraphQL Query\\n      wordcount: {\\n        paragraphs: {\\n          eq: 4\\n        }\\n      }\\n    }\\n  },\\n  nodes: ${latestNodes},\\n  path: context.path, // E.g /blogs/my-blog\\n  typeName: `markdownRemark`,\\n  type: ${gqlType}\\n})\\n\")), mdx(\"h2\", {\n    \"id\": \"run-siftjs\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#run-siftjs\",\n    \"aria-label\": \"run siftjs permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Run-sift.js\"), mdx(\"p\", null, \"This file converts GraphQL Arguments into sift queries and applies them to the collection of all nodes of this type. The rough steps are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Convert query args to sift args\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Drop leaves from args\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Resolve inner query fields on all nodes\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Track newly realized fields\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Run sift query on all nodes\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Create Page dependency if required\")), mdx(\"h3\", {\n    \"id\": \"1-convert-query-args-to-sift-args\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#1-convert-query-args-to-sift-args\",\n    \"aria-label\": \"1 convert query args to sift args permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"1. Convert query args to sift args\"), mdx(\"p\", null, \"Sift expects all field names to be prepended by a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$\"), \". The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/6dc8a14f8efc78425b1f225901dce7264001e962/packages/gatsby/src/redux/run-sift.js#L39\"\n  }), \"siftifyArgs\"), \" function takes care of this. It descends the args tree, performing the following transformations for each field key/value scenario.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"field key is\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"elemMatch\"), \"? Change to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$elemMatch\"), \". Recurse on value object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"field value is regex? Apply regex cleaning\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"field value is glob, use \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/minimatch\"\n  }), \"minimatch\"), \" library to convert to Regex\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"normal value, prepend \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$\"), \" to field name.\")), mdx(\"p\", null, \"So, the above query would become:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  `$wordcount`: {\\n    `$paragraphs`: {\\n      `$eq`: 4\\n    }\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"2-drop-leaves-eg-eq-4-from-args\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#2-drop-leaves-eg-eq-4-from-args\",\n    \"aria-label\": \"2 drop leaves eg eq 4 from args permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"2. Drop leaves (e.g \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"{eq: 4}\"), \") from args\"), mdx(\"p\", null, \"To assist in step 3, we create a version of the siftified args called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldsToSift\"), \" that has all leaves of the args tree replaced with boolean \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \". This is handled by the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/6dc8a14f8efc78425b1f225901dce7264001e962/packages/gatsby/src/redux/run-sift.js#L65\"\n  }), \"extractFieldsToSift\"), \" function. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldsToSift\"), \" would look like this after the function is applied:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n  `wordcount`: {\\n    `paragraphs`: true\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"3-resolve-inner-query-fields-on-all-nodes\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#3-resolve-inner-query-fields-on-all-nodes\",\n    \"aria-label\": \"3 resolve inner query fields on all nodes permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"3. Resolve inner query fields on all nodes\"), mdx(\"p\", null, \"Step 4 will perform the actual sift query over all the nodes, returning the first one that matches the query. But we must remember that the nodes that are in redux only include data that was explicitly created by their source or transform plugins. If instead of creating a data field, a plugin used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFieldsOnGraphQLNodeType\"), \" to define a custom field, then we have to manually call that field\\u2019s resolver on each node. The args in step 2 is a great example. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wordcount\"), \" field is defined by the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-transformer-remark/src/extend-node-type.js#L416\"\n  }), \"gatsby-transformer-remark\"), \" plugin, rather than created during the creation of the remark node.\"), mdx(\"p\", null, \"The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/redux/run-sift.js#L168\"\n  }), \"nodesPromise\"), \" function iterates over all nodes of this type. Then, for each node, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/6dc8a14f8efc78425b1f225901dce7264001e962/packages/gatsby/src/redux/run-sift.js#L135\"\n  }), \"resolveRecursive\"), \" descends the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"siftToFields\"), \" tree, getting the field name, and then finding its gqlType, and then calling that type\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \" function manually. E.g, for the above example, we would find the gqlField for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wordcount\"), \" and call its resolve field:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"markdownRemarkGqlType.resolve(node, {}, {}, { fieldName: `wordcount` })\\n\")), mdx(\"p\", null, \"Note that the graphql-js library has NOT been invoked yet. We\\u2019re instead calling the appropriate gqlType resolve function manually.\"), mdx(\"p\", null, \"The resolve method in this case would return a paragraph node, which also needs to be properly resolved. So We descend the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldsToSift\"), \" arg tree and perform the above operation on the paragraph node (using the found paragraph gqlType).\"), mdx(\"p\", null, \"After \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolveRecursive\"), \" has finished, we will have \\u201Crealized\\u201D all the query fields in each node, giving us confidence that we can perform the query with all the data being there.\"), mdx(\"h3\", {\n    \"id\": \"4-track-newly-realized-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#4-track-newly-realized-fields\",\n    \"aria-label\": \"4 track newly realized fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"4. Track newly realized fields\"), mdx(\"p\", null, \"Since new fields on the node may have been created in this process, we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"trackInlineObjectsInRootNode()\"), \" to track these new objects. See \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-tracking/\"\n  }), \"Node Tracking\"), \" docs for more.\"), mdx(\"h3\", {\n    \"id\": \"5-run-sift-query-on-all-nodes\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#5-run-sift-query-on-all-nodes\",\n    \"aria-label\": \"5 run sift query on all nodes permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"5. Run sift query on all nodes\"), mdx(\"p\", null, \"Now that we\\u2019ve realized all fields that need to be queried, on all nodes of this type, we are finally ready to apply the sift query. This step is handled by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/redux/run-sift.js#L214\"\n  }), \"tempPromise\"), \". It simply concatenates all the top level objects in the args tree together with a sift \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$and\"), \" expression, and then iterates over all nodes returning the first one that satisfies the sift expression.\"), mdx(\"p\", null, \"In the case that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connection === true\"), \" (argument passed to run-sift), then instead of just choosing the first argument, we will select ALL nodes that match the sift query. If the GraphQL query specified \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"skip\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"limit\"), \" fields, then we use the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/graphql-skip-limit\"\n  }), \"graphql-skip-limit\"), \" library to filter down to the appropriate results. See \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/schema-connections\"\n  }), \"Schema Connections\"), \" for more info.\"), mdx(\"h3\", {\n    \"id\": \"6-create-page-dependency-if-required\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#6-create-page-dependency-if-required\",\n    \"aria-label\": \"6 create page dependency if required permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"6. Create Page dependency if required\"), mdx(\"p\", null, \"Assuming we find a node (or multiple if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connection\"), \" === true), we finish off by recording the page that initiated the query (in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" field) depends on the found node. More on this in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/page-node-dependencies/\"\n  }), \"Page -> Node Dependencies\"), \".\"), mdx(\"h2\", {\n    \"id\": \"note-about-plugin-resolver-side-effects\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#note-about-plugin-resolver-side-effects\",\n    \"aria-label\": \"note about plugin resolver side effects permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Note about plugin resolver side effects\"), mdx(\"p\", null, \"As \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#3-resolve-inner-query-fields-on-all-nodes\"\n  }), \"mentioned above\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"run-sift\"), \" must \\u201Crealize\\u201D all query fields before querying over them. This involves calling the resolvers of custom plugins on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"each node of that type\"), \". Therefore, if a resolver performs side effects, then these will be triggered, regardless of whether the field result actually matches the query.\"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "This documentation isn't up to date with latest\n schema customization changes . Help Gatsby by\nmaking a PR to  update this documentationâ€¦",
        "timeToRead": 3,
        "tableOfContents": {
          "items": [
            {
              "url": "#summary",
              "title": "Summary"
            },
            {
              "url": "#processednodetype-resolve-function",
              "title": "ProcessedNodeType Resolve Function"
            },
            {
              "url": "#run-siftjs",
              "title": "Run-sift.js",
              "items": [
                {
                  "url": "#1-convert-query-args-to-sift-args",
                  "title": "1. Convert query args to sift args"
                },
                {
                  "url": "#2-drop-leaves-eg-eq-4-from-args",
                  "title": "2. Drop leaves (e.g {eq: 4}) from args"
                },
                {
                  "url": "#3-resolve-inner-query-fields-on-all-nodes",
                  "title": "3. Resolve inner query fields on all nodes"
                },
                {
                  "url": "#4-track-newly-realized-fields",
                  "title": "4. Track newly realized fields"
                },
                {
                  "url": "#5-run-sift-query-on-all-nodes",
                  "title": "5. Run sift query on all nodes"
                },
                {
                  "url": "#6-create-page-dependency-if-required",
                  "title": "6. Create Page dependency if required"
                }
              ]
            },
            {
              "url": "#note-about-plugin-resolver-side-effects",
              "title": "Note about plugin resolver side effects"
            }
          ]
        },
        "fields": {
          "slug": "/docs/schema-sift/",
          "anchor": "schema-sift"
        },
        "frontmatter": {
          "title": "Querying with Sift",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/schema-sift.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/schema-sift/",
      "prev": {
        "title": "Building the Input Filters",
        "link": "/docs/schema-input-gql/"
      },
      "next": {
        "title": "Connections",
        "link": "/docs/schema-connections/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}