{
  "path": "/blog/2019-03-18-releasing-new-schema-customization/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"New Schema Customization API - Available in Gatsby 2.2.0\",\n  \"date\": \"2019-03-19T00:00:00.000Z\",\n  \"author\": \"Mikhail Novikov\",\n  \"tags\": [\"graphql\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Two weeks ago, we announced our plans for a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/blog/2019-03-04-new-schema-customization/\"\n  }), \"new schema customization API\"), \". Today we are making this set of new APIs and enhancements available to all in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \"@\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2.2.0\"), \".\"), mdx(\"p\", null, \"First, install the latest and greatest version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \", like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install gatsby --save\\n\")), mdx(\"p\", null, \"Next, continue reading below to see if any of the great, new features we\\u2019ve enabled scratch a particular itch. We feel very confident they will \\uD83D\\uDC9C\"), mdx(\"h1\", {\n    \"id\": \"recap-of-schema-customization\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#recap-of-schema-customization\",\n    \"aria-label\": \"recap of schema customization permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Recap of schema customization\"), mdx(\"p\", null, \"Before this change, the Gatsby GraphQL schema was generated automatically from the data that the user added to Gatsby. While very convenient and easy to start, changes to the data could cause changes to the schema, which could cause breakage in unrelated locations. Those bugs were confusing and hard to debug. To alleviate this problem, we\\u2019ve added a schema customization API that lets you customize, fix, and enhance types in your Gatsby GraphQL schema.\"), mdx(\"p\", null, \"There are two new APIs, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \".\"), mdx(\"h2\", {\n    \"id\": \"createtypes\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#createtypes\",\n    \"aria-label\": \"createtypes permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"createTypes\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" can be used to define, fix, or extend a Gatsby GraphQL type that represents some of your app\\u2019s data. Think of it like an escape hatch to politely inform Gatsby of your data\\u2019s shape.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.sourceNodes = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    type AuthorJson implements Node {\\n      name: String\\n      birthday: Date\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"After adding this to your \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/gatsby-project-structure/#files\"\n  }), \"gatsby-node\"), \" file, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson\"), \" type will always have fields name and birthday, regardless of the automatically inferred data shape. The rest of the fields will still be inferred normally, allowing you to enjoy the default benefits of Gatsby schema inference.\"), mdx(\"h2\", {\n    \"id\": \"createresolvers\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#createresolvers\",\n    \"aria-label\": \"createresolvers permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"createResolvers\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" allows doing additional customization after all schema processing has been finished. Thus it can be used to add fields to any types, including root types like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" and types from third party schemas.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"createResolvers({\\n  Query: {\\n    allAuthorFullNames: {\\n      type: `[String!]!`,\\n      resolve(source, args, context, info) {\\n        const authors = context.nodeModel.getAllNodes({\\n          type: `AuthorJson`,\\n        })\\n        return authors.map(author => author.name)\\n      },\\n    },\\n  },\\n})\\n\")), mdx(\"h2\", {\n    \"id\": \"the-type-builder-api\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#the-type-builder-api\",\n    \"aria-label\": \"the type builder api permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"The Type Builder API\"), mdx(\"p\", null, \"While \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" accepts GraphQL types as a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/learn/schema/\"\n  }), \"Schema Definition Language (SDL)\"), \" string, we\\u2019ve also added an option to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" types so that users could create types with resolvers. However, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" is somewhat verbose and it can be hard to refer to types that don\\u2019t yet exist or don\\u2019t exist in a current scope. Therefore, we decided to add another programmatic API that combines brevity of SDL with flexibility of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \".\"), mdx(\"p\", null, \"We refer to this API as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Type Builder API\"), \". It is available in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schema\"), \" field of the arguments object passed to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/\"\n  }), \"Gatsby Node APIs\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.sourceNodes = ({ actions, schema }) => {\\n  const { createTypes } = actions\\n  createTypes([\\n    schema.buildObjectType({\\n      name: `CommentJson`,\\n      fields: {\\n        text: `String!`,\\n        blog: {\\n          type: `BlogJson`,\\n          resolve(parent, args, context) {\\n            return context.nodeModel.getNodeById({\\n              id: parent.author,\\n              type: `BlogJson`,\\n            })\\n          },\\n        },\\n        author: {\\n          type: `AuthorJson`,\\n          resolve(parent, args, context) {\\n            return context.nodeModel.getNodeById({\\n              id: parent.author,\\n              type: `AuthorJson`,\\n            })\\n          },\\n        },\\n      },\\n      interfaces: [`Node`],\\n    }),\\n  ])\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"potential-for-breaking-changes\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#potential-for-breaking-changes\",\n    \"aria-label\": \"potential for breaking changes permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Potential for Breaking Changes\"), mdx(\"p\", null, \"We have tried to avoid any breaking changes in this refactor of the underlying GraphQL layer, testing it in notable Gatsby sites and ensuring all tests were passing. However, there are areas where we needed to introduce more stable naming, and in these instances it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"could\"), \" be possible that a breaking change was introduced if you were relying on this undocumented API.\"), mdx(\"p\", null, \"Specifically, before this refactor Gatsby type names weren\\u2019t stable. They could have names like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter_2\"), \" because of some quirks in our schema generation. Now the types names are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"stable\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"defined\"), \". For a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node\"), \", it\\u2019s always a Pascal Camel Cased name of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node\"), \" type (for example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \"). For an inline object, it\\u2019s the name of the node plus the name of the field, again Pascal Camel Cased. So \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter_2\"), \" would be available as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemarkFrontmatter\"), \" now. If you\\u2019ve had fragments referring to some types by their old names, you may need to change it to new names, e.g.:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"- fragment someFragment on frontmatter_2 {\\n+ fragment someFragment on MarkdownRemarkFrontmatter {\\n  title\\n}\\n\")), mdx(\"p\", null, \"Another change relates to inference. Previously, ordering of the Nodes in your data source could affect which type Gatsby inferred. Now, we always consider all possible types, thus you might experience type conflicts for conflicting data sources. They can be solved by either fixing the data or defining a type using new schema customization APIs that we\\u2019ve exposed.\"), mdx(\"h1\", {\n    \"id\": \"wrap-up\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#wrap-up\",\n    \"aria-label\": \"wrap up permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Wrap-up\"), mdx(\"p\", null, \"As next steps, we will work on adding more convenient tooling to \\u201Cfreeze\\u201D your schema type definitions, so that you can quickly start using this feature. We will also be working on improving API docs for this.\"), mdx(\"p\", null, \"We strongly believe that these new APIs are the foundation of an evolutionary leap of the Gatsby GraphQL API. These changes make the GraphQL API more stable, more robust, and more easily customizable. They will enable further customization and use cases, like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/blog/2018-11-11-introducing-gatsby-themes/\"\n  }), \"theming\"), \" and more still that we haven\\u2019t even envisioned yet. We truly can\\u2019t wait to see the great things you build and how you use these new APIs and improvements powered by Gatsby and its improved GraphQL layer. We got some very enthusiastic feedback about this feature and we are happy to have it released.\"), mdx(\"blockquote\", {\n    className: \"twitter-tweet\",\n    \"data-lang\": \"en\"\n  }, mdx(\"p\", {\n    lang: \"en\",\n    dir: \"ltr\"\n  }, \"Wow, this is huge, and could potentially solve most of the issues users are currently experiencing integrating any CMS with\", \" \", mdx(\"a\", {\n    href: \"https://twitter.com/gatsbyjs?ref_src=twsrc%5Etfw\"\n  }, \"@gatsbyjs\"), \"! Great work guys, can't wait to do some tests with our source plugin! \\uD83C\\uDFC6\", \" \", mdx(\"a\", {\n    href: \"https://t.co/REcehYiU8V\"\n  }, \"https://t.co/REcehYiU8V\")), \"\\u2014 DatoCMS (@datocms)\", \" \", mdx(\"a\", {\n    href: \"https://twitter.com/datocms/status/1103896814351048704?ref_src=twsrc%5Etfw\"\n  }, \"March 8, 2019\")), mdx(\"h2\", {\n    \"id\": \"additional-resources\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#additional-resources\",\n    \"aria-label\": \"additional resources permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Additional Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/issues/12272\"\n  }), \"Meta issue\"), \" for bug reports\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/actions/#createTypes\"\n  }), \"API docs for createTypes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/node-apis/#createResolvers\"\n  }), \"API docs for createResolvers\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/docs/node-model\"\n  }), \"API docs for node model\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions\"\n  }), \"Using type definitions example\"))));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "Two weeks ago, we announced our plans for a  new schema customization API . Today we are making this set of new APIs and enhancements…",
        "timeToRead": 3,
        "fields": {
          "slug": "/blog/2019-03-18-releasing-new-schema-customization/",
          "publishedAt": null
        },
        "frontmatter": {
          "title": "New Schema Customization API - Available in Gatsby 2.2.0",
          "excerpt": null,
          "date": "March 19th 2019",
          "rawDate": "2019-03-19T00:00:00.000Z",
          "canonicalLink": null,
          "tags": [
            "graphql"
          ],
          "image": null,
          "imageAuthor": null,
          "imageAuthorLink": null,
          "imageTitle": null,
          "showImageInArticle": null,
          "author": {
            "id": "Mikhail Novikov",
            "bio": "GraphQL sommelier. Did Reindex, GraphQL Delegation, Schema Stitching, Launchpad. Organizer @GraphQLFinland.",
            "twitter": "@freiksenet",
            "avatar": {
              "childImageSharp": {
                "fixed": {
                  "tracedSVG": "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%3e%3crect%20width='100%25'%20height='100%25'%20fill='%23f6f2f8'/%3e%3cpath%20d='M12%209v8l2%204%201%203%201%203-1%203h5c6%200%207%200%205-5v-6c0-2-4-3-4-1l-3%201c-2%200-3-7-2-9l1-2c-2-2-4-1-5%201'%20fill='%23e0d6eb'%20fill-rule='evenodd'/%3e%3c/svg%3e",
                  "width": 64,
                  "height": 64,
                  "src": "/static/5429bb44f659c90adf5ad9756da87eaa/88ae8/freiksenet.jpg",
                  "srcSet": "/static/5429bb44f659c90adf5ad9756da87eaa/88ae8/freiksenet.jpg 1x,\n/static/5429bb44f659c90adf5ad9756da87eaa/0740f/freiksenet.jpg 1.5x,\n/static/5429bb44f659c90adf5ad9756da87eaa/c9264/freiksenet.jpg 2x"
                }
              }
            },
            "fields": {
              "slug": "/contributors/mikhail-novikov/"
            }
          }
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/blog/2019-03-18-releasing-new-schema-customization/",
      "prev": {
        "fields": {
          "slug": "/blog/2019-03-15-design-code-blog-post/",
          "package": null,
          "released": true
        },
        "frontmatter": {
          "title": "Gatsby Fuels Content and Sales in Design+Code Rebuild",
          "draft": null,
          "canonicalLink": null,
          "publishedAt": null,
          "issue": null,
          "tags": [
            "case-studies"
          ]
        }
      },
      "next": {
        "fields": {
          "slug": "/blog/2019-03-21-migrating-from-wordpress-to-gatsby/",
          "package": null,
          "released": true
        },
        "frontmatter": {
          "title": "Migrating From WordPress to Gatsby",
          "draft": null,
          "canonicalLink": "https://www.taniarascia.com/migrating-from-wordpress-to-gatsby/",
          "publishedAt": null,
          "issue": null,
          "tags": [
            "wordpress",
            "migration",
            "blogs"
          ]
        }
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateBlogPostJs2991924798(\n  $slug: String!\n) {\n  mdx(fields: {slug: {eq: $slug}}) {\n    body\n    excerpt\n    timeToRead\n    fields {\n      slug\n      publishedAt\n    }\n    frontmatter {\n      title\n      excerpt\n      date(formatString: \"MMMM Do YYYY\")\n      rawDate: date\n      canonicalLink\n      tags\n      image {\n        childImageSharp {\n          resize(width: 1500, height: 1500) {\n            src\n          }\n          fluid(maxWidth: 786) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n      imageAuthor\n      imageAuthorLink\n      imageTitle\n      showImageInArticle\n      author {\n        id\n        bio\n        twitter\n        avatar {\n          childImageSharp {\n            fixed(width: 64, height: 64, quality: 75, traceSVG: {turdSize: 10, background: \"#f6f2f8\", color: \"#e0d6eb\"}) {\n              ...GatsbyImageSharpFixed_tracedSVG\n            }\n          }\n        }\n        fields {\n          slug\n        }\n      }\n    }\n  }\n}\n\nfragment GatsbyImageSharpFluid on ImageSharpFluid {\n  base64\n  aspectRatio\n  src\n  srcSet\n  sizes\n}\n\nfragment GatsbyImageSharpFixed_tracedSVG on ImageSharpFixed {\n  tracedSVG\n  width\n  height\n  src\n  srcSet\n}\n"
}