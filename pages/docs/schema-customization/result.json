{
  "path": "/docs/schema-customization/",
  "result": {
    "data": {
      "mdx": {
        "body": "function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"customizing-the-graphql-schema\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#customizing-the-graphql-schema\",\n    \"aria-label\": \"customizing the graphql schema permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Customizing the GraphQL Schema\"), mdx(\"p\", null, \"One of Gatsby\\u2019s main strengths is the ability to query data from a variety of\\nsources in a uniform way with GraphQL. For this to work, a GraphQL Schema must\\nbe generated that defines the shape of the data.\"), mdx(\"p\", null, \"Gatsby is able to automatically infer a GraphQL Schema from your data, and in\\nmany cases this is really all you need. There are however situations when you\\neither want to explicitly define the data shape, or add custom functionality to\\nthe query layer - this is what Gatsby\\u2019s Schema Customization API provides.\"), mdx(\"p\", null, \"The following guide walks through some examples to showcase the API.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This guide is aimed at plugin authors, users trying to fix GraphQL schemas\\ncreated by automatic type inference, developers optimizing builds for larger\\nsites, and anyone interested in customizing Gatsby\\u2019s schema generation.\\nAs such, the guide assumes that you\\u2019re somewhat familiar with GraphQL types\\nand with using Gatsby\\u2019s Node APIs.\")), mdx(\"h2\", {\n    \"id\": \"explicitly-defining-data-types\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#explicitly-defining-data-types\",\n    \"aria-label\": \"explicitly defining data types permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Explicitly defining data types\"), mdx(\"p\", null, \"Our example project is a blog that gets its data from local Markdown files which\\nprovide the post contents, as well as author information in JSON format. We also\\nhave occasional guest contributors whose info we keep in a separate JSON file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-markdown:title=src/data/post1.md\"\n  }), \"---\\ntitle: Sample Post\\npublishedAt: 2019-04-01\\nauthor: jane@example.com\\ntags:\\n  - wow\\n---\\n\\n# Heading\\n\\nText\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json:title=src/data/author.json\"\n  }), \"[\\n  {\\n    \\\"name\\\": \\\"Doe\\\",\\n    \\\"firstName\\\": \\\"Jane\\\",\\n    \\\"email\\\": \\\"jane@example.com\\\",\\n    \\\"joinedAt\\\": \\\"2018-01-01\\\"\\n  }\\n]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json:title=src/data/contributor.json\"\n  }), \"[\\n  {\\n    \\\"name\\\": \\\"Doe\\\",\\n    \\\"firstName\\\": \\\"Zoe\\\",\\n    \\\"email\\\": \\\"zoe@example.com\\\",\\n    \\\"receivedSwag\\\": true\\n  }\\n]\\n\")), mdx(\"p\", null, \"To be able to query the contents of these files with GraphQL, we need to first\\nload them into Gatsby\\u2019s internal data store. This is what source and transformer\\nplugin accomplish - in this case \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-remark\"), \" plus \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-json\"), \". Every markdown post\\nfile is hereby transformed into a \\u201Cnode\\u201D object in the internal data store with\\na unique \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" and a type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \". Similarly, an author will be\\nrepresented by a node object of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson\"), \", and contributor info will be\\ntransformed into node objects of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContributorJson\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-node-interface\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#the-node-interface\",\n    \"aria-label\": \"the node interface permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"The Node interface\"), mdx(\"p\", null, \"This data structure is represented in Gatsby\\u2019s GraphQL schema with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node\"), \"\\ninterface, which describes the set of fields common to node objects created by\\nsource and transformer plugins (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \", as well as a couple\\nof \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal\"), \" fields like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \"). In GraphQL Schema Definition Language (SDL),\\nit looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"interface Node {\\n  id: ID!\\n  parent: Node!\\n  children: [Node!]!\\n  internal: Internal!\\n}\\n\\ntype Internal {\\n  type: String!\\n}\\n\")), mdx(\"p\", null, \"Types created by source and transformer plugins implement this interface. For\\nexample, the node type created by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-json\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authors.json\"), \"\\nwill be represented in the GraphQL schema as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type AuthorJson implements Node {\\n  id: ID!\\n  parent: Node!\\n  children: [Node!]!\\n  internal: Internal!\\n  name: String\\n  firstName: String\\n  email: String\\n  joinedAt: Date\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A quick way to inspect the schema generated by Gatsby is the GraphQL Playground.\\nStart your project with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GATSBY_GRAPHQL_IDE=playground gatsby develop\"), \", open the\\nplayground at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://localhost:8000/___graphql\"), \" and inspect the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Schema\"), \" tab on\\nthe right.\")), mdx(\"h3\", {\n    \"id\": \"automatic-type-inference\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#automatic-type-inference\",\n    \"aria-label\": \"automatic type inference permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Automatic type inference\"), mdx(\"p\", null, \"It\\u2019s important to note that the data in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author.json\"), \" does not provide type\\ninformation of the Author fields by itself. In order to translate the data\\nshape into GraphQL type definitions, Gatsby has to inspect the contents of\\nevery field and check its type. In many cases this works very well and it is\\nstill the default mechanism for creating a GraphQL schema.\"), mdx(\"p\", null, \"There are however two problems with this approach: (1) it is quite\\ntime-consuming and therefore does not scale very well and (2) if the values on a\\nfield are of different types Gatsby cannot decide which one is the correct one.\\nA consequence of this is that if your data sources change, type inference could\\nsuddenly fail.\"), mdx(\"p\", null, \"Both problems can be solved by providing explicit type definitions for Gatsby\\u2019s\\nGraphQL schema.\"), mdx(\"h3\", {\n    \"id\": \"creating-type-definitions\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#creating-type-definitions\",\n    \"aria-label\": \"creating type definitions permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Creating type definitions\"), mdx(\"p\", null, \"Let\\u2019s take the latter case first. Assume a new author joins the team, but in the\\nnew author entry there is a typo on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"joinedAt\"), \" field: \\u201C201-04-02\\u201D which is\\nnot a valid Date.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff:title=src/data/author.json\"\n  }), \"+  {\\n+    \\\"name\\\": \\\"Doe\\\",\\n+    \\\"firstName\\\": \\\"John\\\",\\n+    \\\"email\\\": \\\"john@example.com\\\",\\n+    \\\"joinedAt\\\": \\\"201-04-02\\\"\\n+  }\\n]\\n\")), mdx(\"p\", null, \"This will confuse Gatsby\\u2019s type inference since the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"joinedAt\"), \"\\nfield will now have both Date and String values.\"), mdx(\"h4\", {\n    \"id\": \"fixing-field-types\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#fixing-field-types\",\n    \"aria-label\": \"fixing field types permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Fixing field types\"), mdx(\"p\", null, \"To ensure that the field will always be of Date type, you can provide explicit\\ntype definitions to Gatsby with the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/actions/#createTypes\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"createTypes\")), \" action.\\nIt accepts type definitions in GraphQL Schema Definition Language:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    type AuthorJson implements Node {\\n      joinedAt: Date\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"Note that the rest of the fields (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"firstName\"), \" etc.) don\\u2019t have to be\\nprovided, they will still be handled by Gatsby\\u2019s type inference.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Actions to customize Gatsby\\u2019s schema generation are made available in the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#createSchemaCustomization\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"createSchemaCustomization\")), \"\\n(available in Gatsby v2.12 and above),\\nand \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#sourceNodes\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"sourcesNodes\")), \" APIs.\")), mdx(\"h4\", {\n    \"id\": \"opting-out-of-type-inference\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#opting-out-of-type-inference\",\n    \"aria-label\": \"opting out of type inference permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Opting out of type inference\"), mdx(\"p\", null, \"There are however advantages to providing full definitions for a node type, and\\nbypassing the type inference mechanism altogether. With smaller scale projects\\ninference is usually not a performance problem, but as projects grow the\\nperformance penalty of having to check each field type will become noticeable.\"), mdx(\"p\", null, \"Gatsby allows to opt out of inference with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@dontInfer\"), \" type directive - which\\nin turn requires that you explicitly provide type definitions for all fields\\nthat should be available for querying:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    type AuthorJson implements Node @dontInfer {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n      joinedAt: Date\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"Note that you don\\u2019t need to explicitly provide the Node interface fields (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent\"), \", etc.), Gatsby will automatically add them for you.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you wonder about the exclamation marks - those allow\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/learn/schema/#lists-and-non-null\"\n  }), \"specifying nullability\"), \"\\nin GraphQL, i.e. if a field value is allowed to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" or not.\")), mdx(\"h4\", {\n    \"id\": \"nested-types\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#nested-types\",\n    \"aria-label\": \"nested types permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Nested types\"), mdx(\"p\", null, \"So far we have only been dealing with scalar values (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date\"), \";\\nGraphQL also knows \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ID\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Float\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Boolean\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON\"), \"). Fields can\\nhowever also contain complex object values. To target those fields in GraphQL SDL, you\\ncan provide a full type definition for the nested type, which can be arbitrarily\\nnamed (as long as the name is unique in the schema). In our example project, the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter\"), \" field on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" node type is a good example. Say we\\nwant to ensure that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter.tags\"), \" will always be an array of strings.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    type MarkdownRemark implements Node {\\n      frontmatter: Frontmatter\\n    }\\n    type Frontmatter {\\n      tags: [String!]!\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"Note that with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" we cannot directly target a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Frontmatter\"), \" type\\nwithout also specifying that this is the type of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter\"), \" field on the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" type, The following would fail because Gatsby would have no way\\nof knowing which field the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Frontmatter\"), \" type should be applied to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    # This will fail!!!\\n    type Frontmatter {\\n      tags: [String]!\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"It is useful to think about your data, and the corresponding GraphQL schema, by\\nalways starting from the Node types created by source and transformer plugins.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Frontmatter\"), \" type must not implement the Node interface since\\nit is not a top-level type created by source or transformer plugins: it has no\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field, and is just there to describe the data shape on a nested field.\")), mdx(\"h4\", {\n    \"id\": \"gatsby-type-builders\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#gatsby-type-builders\",\n    \"aria-label\": \"gatsby type builders permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Gatsby Type Builders\"), mdx(\"p\", null, \"In many cases, GraphQL SDL provides a succinct way to provide type definitions\\nfor your schema. If however you need more flexibility, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" also\\naccepts type definitions provided with the help of Gatsby Type Builders, which\\nare more flexible than SDL syntax but less verbose than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \". They are\\naccessible on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schema\"), \" argument passed to Node APIs.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions, schema }) => {\\n  const { createTypes } = actions\\n  const typeDefs = [\\n    schema.buildObjectType({\\n      name: \\\"ContributorJson\\\",\\n      fields: {\\n        name: \\\"String!\\\",\\n        firstName: \\\"String!\\\",\\n        email: \\\"String!\\\",\\n        receivedSwag: {\\n          type: \\\"Boolean\\\",\\n          resolve: source => source.receivedSwag || false,\\n        },\\n      },\\n      interfaces: [\\\"Node\\\"],\\n    }),\\n  ]\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"Gatsby Type Builders allow referencing types as simple strings, and accept full\\nfield configs (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \"). When defining top-level types, don\\u2019t forget\\nto pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interfaces: ['Node']\"), \", which does the same for Type Builders as adding\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"implements Node\"), \" does for SDL-defined types. It is also possible to opt out of type\\ninference with Type Builders by setting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"infer\"), \" type extension to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"schema.buildObjectType({\\n  name: \\\"ContributorJson\\\",\\n  fields: {\\n    name: \\\"String!\\\",\\n  },\\n  interfaces: [\\\"Node\\\"],\\n+ extensions: {\\n+   // While in SDL we have two different directives, @infer and @dontInfer to\\n+   // control inference behavior, Gatsby Type Builders take a single `infer`\\n+   // extension which accepts a Boolean\\n+   infer: false\\n+ },\\n}),\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Type Builders also exist for Input, Interface and Union types:\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"buildInputType\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"buildInterfaceType\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"buildUnionType\"), \".\\nNote that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" action also accepts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-js\"), \" types directly,\\nbut usually either SDL or Type Builders are the better alternatives.\")), mdx(\"h4\", {\n    \"id\": \"foreign-key-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#foreign-key-fields\",\n    \"aria-label\": \"foreign key fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Foreign-key fields\"), mdx(\"p\", null, \"Gatsby\\u2019s automatic type inference has one trick up its sleeve: for every field\\nthat ends in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \" it will interpret the field value as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" and create a\\nforeign-key relation.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: Before the introduction of the Schema Customization APIs in Gatsby v2.2,\\nthere were two mechanisms to create links between node types: a plugin author would use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \"\\nfieldname convention (for plugins), and a user would define \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/gatsby-config/#mapping-node-types\"\n  }), \"mappings\"), \" between fields in their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-config.js\"), \". Both users and plugin authors can now use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@link\"), \" extension described below.\")), mdx(\"p\", null, \"Creating foreign-key relations with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" action,\\ni.e. without relying on type inference and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \" field naming\\nconvention, requires a bit of manual setup.\"), mdx(\"p\", null, \"In our example project, we want the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter.author\"), \" field on\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" nodes to expand the provided field value to a full \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson\"), \" node.\\nFor this to work, we have to provide a custom field resolver. (see below for\\nmore info on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context.nodeModel\"), \")\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions, schema }) => {\\n  const { createTypes } = actions\\n  const typeDefs = [\\n    \\\"type MarkdownRemark implements Node { frontmatter: Frontmatter }\\\",\\n    schema.buildObjectType({\\n      name: \\\"Frontmatter\\\",\\n      fields: {\\n        author: {\\n          type: \\\"AuthorJson\\\",\\n          resolve: (source, args, context, info) => {\\n            // If we were linking by ID, we could use `getNodeById` to\\n            // find the correct author:\\n            // return context.nodeModel.getNodeById({\\n            //   id: source.author,\\n            //   type: \\\"AuthorJson\\\",\\n            // })\\n            // But since we are using the author email as foreign key,\\n            // we can use `runQuery`, or get all author nodes\\n            // with `getAllNodes` and manually find the linked author\\n            // node:\\n            return context.nodeModel\\n              .getAllNodes({ type: \\\"AuthorJson\\\" })\\n              .find(author => author.email === source.author)\\n          },\\n        },\\n      },\\n    }),\\n  ]\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"What is happening here is that we provide a custom field resolver that asks\\nGatsby\\u2019s internal data store for the the full node object with the specified\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \".\"), mdx(\"p\", null, \"Because creating foreign-key relations is such a common usecase, Gatsby\\nluckily also provides a much easier way to do this \\u2014 with the help of\\nextensions or directives. It looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type MarkdownRemark implements Node {\\n  frontmatter: Frontmatter\\n}\\ntype Frontmatter {\\n  author: AuthorJson @link # default foreign-key relation by `id`\\n  reviewers: [AuthorJson] @link(by: \\\"email\\\") # foreign-key relation by custom field\\n}\\ntype AuthorJson implements Node {\\n  posts: [MarkdownRemark] @link(by: \\\"frontmatter.author.email\\\", from: \\\"email\\\") # easy back-ref\\n}\\n\")), mdx(\"p\", null, \"You provide a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@link\"), \" directive on a field and Gatsby will internally\\nadd a resolver that is quite similar to the one we wrote manually above. If no\\nargument is provided, Gatsby will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field as the foreign-key,\\notherwise the foreign-key has to be provided with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"by\"), \" argument. The\\noptional \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"from\"), \" argument allows getting the field on the current type which acts as the foreign-key to the field specified in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"by\"), \".\\nIn other words, you \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"on\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"from\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"to\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"by\"), \". This makes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"from\"), \" especially helpful when adding a field for back-linking.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note that when using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" to fix type inference for a foreign-key field\\ncreated by a plugin, the underlying data will probably live on a field with\\na \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"___NODE\"), \" suffix. Use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"from\"), \" argument to point the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" extension to\\nthe correct field name. For example: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author: [AuthorJson] @link(from: \\\"author___NODE\\\")\"), \".\")), mdx(\"h4\", {\n    \"id\": \"extensions-and-directives\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#extensions-and-directives\",\n    \"aria-label\": \"extensions and directives permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Extensions and directives\"), mdx(\"p\", null, \"Out of the box, Gatsby provides \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/actions/#createTypes\"\n  }), \"four extensions\"), \"\\nthat allow adding custom functionality to fields without having to manually\\nwrite field resolvers: the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" extension has already been discussed above,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dateformat\"), \" allows adding date formatting options, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fileByRelativePath\"), \" is\\nsimilar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" but will resolve relative paths when linking to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" nodes,\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"proxy\"), \" is helpful when dealing with data that contains field names with\\ncharacters that are invalid in GraphQL.\"), mdx(\"p\", null, \"To add an extension to a field you can either use a directive in SDL, or the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extensions\"), \" property when using Gatsby Type Builders:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ action, schema }) => {\\n  const { createTypes } = actions\\n  const typeDefs = [\\n    \\\"type MarkdownRemark implements Node { frontmatter: Frontmatter }\\\",\\n    `type Frontmatter {\\n      publishedAt: Date @dateformat(formatString: \\\"DD-MM-YYYY\\\")\\n    }`\\n    schema.buildObjectType({\\n      name: 'AuthorJson',\\n      fields: {\\n        joinedAt: {\\n          type: 'Date',\\n          extensions: {\\n            dateformat: {}\\n          }\\n        }\\n      }\\n    })\\n  ]\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"The above example adds \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/graphql-reference/#dates\"\n  }), \"date formatting options\"), \"\\nto the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson.joinedAt\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark.frontmatter.publishedAt\"), \"\\nfields. Those options are available as field arguments when querying those fields:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  allAuthorJson {\\n    joinedAt(fromNow: true)\\n  }\\n}\\n\")), mdx(\"p\", null, \"For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"publishedAt\"), \" we also provide a default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"formatString\"), \" which will be used\\nwhen no explicit formatting options are provided in the query.\"), mdx(\"h4\", {\n    \"id\": \"setting-default-field-values\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#setting-default-field-values\",\n    \"aria-label\": \"setting default field values permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Setting default field values\"), mdx(\"p\", null, \"For setting default field values, Gatsby currently does not (yet) provide an\\nout-of-the-box extension, so resolving a field to a default value (instead of\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \") requires manually adding a field resolver. For example, to add a default\\ntag to every blog post:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ action, schema }) => {\\n  const { createTypes } = actions\\n  const typeDefs = [\\n    \\\"type MarkdownRemark implements Node { frontmatter: Frontmatter }\\\",\\n    schema.buildObjectType({\\n      name: \\\"Frontmatter\\\",\\n      fields: {\\n        tags: {\\n          type: \\\"[String!]\\\",\\n          resolve(source, args, context, info) {\\n            // For a more generic solution, we could pick the field value from\\n            // `source[info.fieldName]`\\n            const { tags } = source\\n            if (source.tags == null || (Array.isArray(tags) && !tags.length)) {\\n              return [\\\"uncategorized\\\"]\\n            }\\n            return tags\\n          },\\n        },\\n      },\\n    }),\\n  ]\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"creating-custom-extensions\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#creating-custom-extensions\",\n    \"aria-label\": \"creating custom extensions permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Creating custom extensions\"), mdx(\"p\", null, \"With the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/actions/#createFieldExtension\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"createFieldExtension\")), \" action\\nit is possible to define custom extensions as a way to add reusable functionality\\nto fields. Let\\u2019s say we want to add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fullName\"), \" field to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContributorJson\"), \".\"), mdx(\"p\", null, \"We could of course write a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fullNameResolver\"), \", and use it in two places:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"const fullNameResolver = source => `${source.firstName} ${source.name}`\\n\\nexports.createSchemaCustomization = ({ actions, schema }) => {\\n  actions.createTypes([\\n    {\\n      name: \\\"AuthorJson\\\",\\n      interfaces: [\\\"Node\\\"],\\n      fields: {\\n        fullName: {\\n          type: \\\"String\\\",\\n          resolve: fullNameResolver,\\n        },\\n      },\\n    },\\n    {\\n      name: \\\"ContributorJson\\\",\\n      interfaces: [\\\"Node\\\"],\\n      fields: {\\n        fullName: {\\n          type: \\\"String\\\",\\n          resolve: fullNameResolver,\\n        },\\n      },\\n    },\\n  ])\\n}\\n\")), mdx(\"p\", null, \"However, to make this functionality available to other plugins as well, and make\\nit usable in SDL, we can register it as a field extension.\"), mdx(\"p\", null, \"A field extension definition requires a name, and an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" function, which\\nshould return a (partial) field config (an object, with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \")\\nwhich will be merged into the existing field config.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createFieldExtension, createTypes } = actions\\n\\n  createFieldExtension({\\n    name: \\\"fullName\\\",\\n    extend(options, prevFieldConfig) {\\n      return {\\n        resolve(source) {\\n          return `${source.firstName} ${source.name}`\\n        },\\n      }\\n    },\\n  })\\n\\n  createTypes(`\\n    type AuthorJson implements Node {\\n      fullName: String @fullName\\n    }\\n    type ContributorJson implements Node {\\n      fullName: String @fullName\\n    }\\n  `)\\n}\\n\")), mdx(\"p\", null, \"This approach becomes a lot more powerful when plugins provide custom field\\nextensions. A \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" basic markdown transformer plugin could for example provide\\nan extension to convert markdown strings into html:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-transformer-basic-md/src/gatsby-node.js\"\n  }), \"const remark = require(`remark`)\\nconst html = require(`remark-html`)\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  actions.createFieldExtension({\\n    name: \\\"md\\\",\\n    args: {\\n      sanitize: {\\n        type: \\\"Boolean!\\\",\\n        defaultValue: true,\\n      },\\n    },\\n    // The extension `args` (above) are passed to `extend` as\\n    // the first argument (`options` below)\\n    extend(options, prevFieldConfig) {\\n      return {\\n        args: {\\n          sanitize: \\\"Boolean\\\",\\n        },\\n        resolve(source, args, context, info) {\\n          const fieldValue = context.defaultFieldResolver(\\n            source,\\n            args,\\n            context,\\n            info\\n          )\\n          const shouldSanitize =\\n            args.sanitize != null ? args.sanitize : options.sanitize\\n          const processor = remark().use(html, { sanitize: shouldSanitize })\\n          return processor.processSync(fieldValue).contents\\n        },\\n      }\\n    },\\n  })\\n}\\n\")), mdx(\"p\", null, \"It can then be used in any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" call by simply adding the directive/extension\\nto the field:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  actions.createTypes(`\\n    type BlogPost implements Node {\\n      content: String @md\\n    }\\n  `)\\n}\\n\")), mdx(\"p\", null, \"Note that in the above example, we have additionally provided configuration options\\nwith \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \". This is e.g. useful to provide default field arguments:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  actions.createTypes(`\\n    type BlogPost implements Node {\\n      content: String @md(sanitize: false)\\n    }\\n  `)\\n}\\n\")), mdx(\"p\", null, \"Also note that field extensions can decide themselves if an existing field resolver\\nshould be wrapped or overwritten. The above examples have all decided to simply return\\na new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \" function. Because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" function receives the current field\\nconfig as its second argument, an extension can also decide to wrap an existing resolver:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"extend(options, prevFieldConfig) {\\n+  const { resolve } = prevFieldConfig\\n+  return {\\n+    async resolve(source, args, context, info) {\\n+      const resultFromPrevResolver = await resolve(source, args, context, info)\\n      /* ... */\\n+      return processor.processSync(resultFromPrevResolver).contents\\n+    }\\n+  }\\n}\\n\")), mdx(\"p\", null, \"If multiple field extensions are added to a field, resolvers are processed in this order:\\nfirst a custom resolver added with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" (or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \") runs, then field\\nextension resolvers execute from left to right.\"), mdx(\"p\", null, \"Finally, note that in order to get the current fieldValue, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context.defaultFieldResolver\"), \".\"), mdx(\"h2\", {\n    \"id\": \"createresolvers-api\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#createresolvers-api\",\n    \"aria-label\": \"createresolvers api permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"createResolvers API\"), mdx(\"p\", null, \"While it is possible to directly pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolvers\"), \" along the type\\ndefinitions using Gatsby Type Builders, an alternative approach specifically\\ntailored towards adding custom resolvers to fields is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" Node\\nAPI.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers }) => {\\n  const resolvers = {\\n    Frontmatter: {\\n      author: {\\n        resolve(source, args, context, info) {\\n          return context.nodeModel.getNodeById({\\n            id: source.author,\\n            type: \\\"AuthorJson\\\",\\n          })\\n        },\\n      },\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" allows adding new fields to types, modifying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolver\"), \" \\u2014 but not overriding the field type. This is because\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" is run last in schema generation, and modifying a field type\\nwould mean having to regenerate corresponding input types (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \"),\\nwhich we want to avoid. If possible, specifying field types should be done with\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" action.\"), mdx(\"h3\", {\n    \"id\": \"accessing-gatsbys-data-store-from-field-resolvers\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#accessing-gatsbys-data-store-from-field-resolvers\",\n    \"aria-label\": \"accessing gatsbys data store from field resolvers permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Accessing Gatsby\\u2019s data store from field resolvers\"), mdx(\"p\", null, \"As mentioned above, Gatsby\\u2019s internal data store and query capabilities are\\navailable to custom field resolvers on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context.nodeModel\"), \" argument passed\\nto every resolver. Accessing node(s) by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" (and optional \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \") is possible\\nwith \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/#getNodeById\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"getNodeById\")), \" and\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/#getNodesByIds\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"getNodesByIds\")), \". To get all nodes, or all\\nnodes of a certain type, use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/#getAllNodes\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"getAllNodes\")), \".\\nAnd running a query from inside your resolver functions can be accomplished\\nwith \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/#runQuery\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"runQuery\")), \", which accepts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \"\\nquery arguments.\"), mdx(\"p\", null, \"We could for example add a field to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorJson\"), \" type that lists all recent\\nposts by an author:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers }) => {\\n  const resolvers = {\\n    AuthorJson: {\\n      recentPosts: {\\n        type: [\\\"MarkdownRemark\\\"],\\n        resolve(source, args, context, info) {\\n          return context.nodeModel.runQuery({\\n            query: {\\n              filter: {\\n                frontmatter: {\\n                  author: { eq: source.email },\\n                  date: { gt: \\\"2019-01-01\\\" },\\n                },\\n              },\\n            },\\n            type: \\\"MarkdownRemark\\\",\\n            firstOnly: false,\\n          })\\n        },\\n      },\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"p\", null, \"When using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runQuery\"), \" to sort query results, be aware that both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort.fields\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort.order\"), \" are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLList\"), \" fields. Also, nested fields on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort.fields\"), \"\\nhave to be provided in dot-notation (not separated by triple underscores).\\nFor example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"context.nodeModel.runQuery({\\n  query: {\\n    sort: {\\n      fields: [\\\"frontmatter.publishedAt\\\"],\\n      order: [\\\"DESC\\\"],\\n    },\\n  },\\n  type: \\\"MarkdownRemark\\\",\\n})\\n\")), mdx(\"h3\", {\n    \"id\": \"custom-query-fields\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#custom-query-fields\",\n    \"aria-label\": \"custom query fields permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Custom query fields\"), mdx(\"p\", null, \"One powerful approach enabled by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" is adding custom root query\\nfields. While the default root query fields added by Gatsby (e.g.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"markdownRemark\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allMarkdownRemark\"), \") provide the whole range of query\\noptions, query fields designed specifically for your project can be useful. For\\nexample, we can add a query field for all external contributors to our example blog\\nwho have received their swag:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers }) => {\\n  const resolvers = {\\n    Query: {\\n      contributorsWithSwag: {\\n        type: [\\\"ContributorJson\\\"],\\n        resolve(source, args, context, info) {\\n          return context.nodeModel.runQuery({\\n            query: {\\n              filter: {\\n                receivedSwag: { eq: true },\\n              },\\n            },\\n            type: \\\"ContributorJson\\\",\\n            firstOnly: false,\\n          })\\n        },\\n      },\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"p\", null, \"Because we might also be interested in the reverse - which contributors haven\\u2019t\\nreceived their swag yet - why not add a (required) custom query arg?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers }) => {\\n  const resolvers = {\\n    Query: {\\n      contributors: {\\n        type: [\\\"ContributorJson\\\"],\\n        args: {\\n          receivedSwag: \\\"Boolean!\\\",\\n        },\\n        resolve(source, args, context, info) {\\n          return context.nodeModel.runQuery({\\n            query: {\\n              filter: {\\n                receivedSwag: { eq: args.receivedSwag },\\n              },\\n            },\\n            type: \\\"ContributorJson\\\",\\n            firstOnly: false,\\n          })\\n        },\\n      },\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"p\", null, \"It is also possible to provide more complex custom input types which can be defined\\ndirectly inline in SDL. We could for example add a field to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ContributorJson\"), \"\\ntype that counts the number of posts by a contributor, and then add a custom root\\nquery field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contributors\"), \" which accepts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"min\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"max\"), \" arguments to only return\\ncontributors who have written at least \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"min\"), \", or at most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"max\"), \" number of posts:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({ createResolvers }) => {\\n  const resolvers = {\\n    Query: {\\n      contributors: {\\n        type: [\\\"ContributorJson\\\"],\\n        args: {\\n          postsCount: \\\"input PostsCountInput { min: Int, max: Int }\\\",\\n        },\\n        resolve(source, args, context, info) {\\n          const { max, min = 0 } = args.postsCount || {}\\n          const operator = max != null ? { lte: max } : { gte: min }\\n          return context.nodeModel.runQuery({\\n            query: {\\n              filter: {\\n                posts: operator,\\n              },\\n            },\\n            type: \\\"ContributorJson\\\",\\n            firstOnly: false,\\n          })\\n        },\\n      },\\n    },\\n    ContributorJson: {\\n      posts: {\\n        type: `Int`,\\n        resolve: (source, args, context, info) => {\\n          return context.nodeModel\\n            .getAllNodes({ type: \\\"MarkdownRemark\\\" })\\n            .filter(post => post.frontmatter.author === source.email).length\\n        },\\n      },\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"taking-care-of-hot-reloading\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#taking-care-of-hot-reloading\",\n    \"aria-label\": \"taking care of hot reloading permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Taking care of hot reloading\"), mdx(\"p\", null, \"When creating custom field resolvers, it is important to ensure that Gatsby\\nknows about the data a page depends on for hot reloading to work properly. When\\nyou retrieve nodes from the store with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"context.nodeModel\")), \" methods,\\nit is usually not necessary to do anything manually, because Gatsby will register\\ndependencies for the query results automatically. The exception is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getAllNodes\"), \"\\nwhich will \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" register data dependencies by default. This is because\\nrequesting re-running of queries when any node of a certain type changes is\\npotentially a very expensive operation. If you are sure you really need this,\\nyou can add a page data dependency either programmatically with\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-model/#trackPageDependencies\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"context.nodeModel.trackPageDependencies\")), \", or with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"context.nodeModel.getAllNodes(\\n  { type: \\\"MarkdownRemark\\\" },\\n  { connectionType: \\\"MarkdownRemark\\\" }\\n)\\n\")), mdx(\"h2\", {\n    \"id\": \"custom-interfaces-and-unions\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#custom-interfaces-and-unions\",\n    \"aria-label\": \"custom interfaces and unions permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Custom Interfaces and Unions\"), mdx(\"p\", null, \"Finally, let\\u2019s say we want to have a page on our example blog that lists all\\nteam members (authors and contributors). What we could do is have two queries,\\none for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allAuthorJson\"), \" and one for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allContributorJson\"), \" and manually merge\\nthose. GraphQL however provides a more elegant solution to these kinds of\\nproblems with \\u201Cabstract types\\u201D (Interfaces and Unions). Since authors and\\ncontributors actually share most of the fields, we can abstract those up into\\na \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TeamMember\"), \" interface and add a custom query field for all team members\\n(as well as a custom resolver for full names):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    interface TeamMember {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n    }\\n\\n    type AuthorJson implements Node & TeamMember {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n      joinedAt: Date\\n    }\\n\\n    type ContributorJson implements Node & TeamMember {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n      receivedSwag: Boolean\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\\nexports.createResolvers = ({ createResolvers }) => {\\n  const fullName = {\\n    type: \\\"String\\\",\\n    resolve(source, args, context, info) {\\n      return source.firstName + \\\" \\\" + source.name\\n    },\\n  }\\n  const resolvers = {\\n    Query: {\\n      allTeamMembers: {\\n        type: [\\\"TeamMember\\\"],\\n        resolve(source, args, context, info) {\\n          return context.nodeModel.getAllNodes({ type: \\\"TeamMember\\\" })\\n        },\\n      },\\n    },\\n    AuthorJson: {\\n      fullName,\\n    },\\n    ContributorJson: {\\n      fullName,\\n    },\\n  }\\n  createResolvers(resolvers)\\n}\\n\")), mdx(\"p\", null, \"To use the newly added root query field in a page query to get the full names of\\nall team members, we can write:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export const query = graphql`\\n  {\\n    allTeamMembers {\\n      ... on AuthorJson {\\n        fullName\\n      }\\n      ... on ContributorJson {\\n        fullName\\n      }\\n    }\\n  }\\n`\\n\")), mdx(\"h3\", {\n    \"id\": \"queryable-interfaces-with-the-nodeinterface-extension\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#queryable-interfaces-with-the-nodeinterface-extension\",\n    \"aria-label\": \"queryable interfaces with the nodeinterface extension permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Queryable interfaces with the \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"@nodeInterface\"), \" extension\"), mdx(\"p\", null, \"Since Gatsby 2.13.22, we can achieve the same thing as above by adding the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@nodeInterface\"), \"\\nextension to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TeamMember\"), \" interface. This will treat the interface like a normal\\ntop-level type that implements the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node\"), \" interface, and thus automatically add root\\nquery fields for the interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes } = actions\\n  const typeDefs = `\\n    interface TeamMember @nodeInterface {\\n      id: ID!\\n      name: String!\\n      firstName: String!\\n      email: String!\\n    }\\n\\n    type AuthorJson implements Node & TeamMember {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n      joinedAt: Date\\n    }\\n\\n    type ContributorJson implements Node & TeamMember {\\n      name: String!\\n      firstName: String!\\n      email: String!\\n      receivedSwag: Boolean\\n    }\\n  `\\n  createTypes(typeDefs)\\n}\\n\")), mdx(\"p\", null, \"When querying, use inline fragments for the fields that are specific to the types\\nimplementing the interface (i.e. fields that are not shared):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export const query = graphql`\\n  {\\n    allTeamMember {\\n      nodes {\\n        name\\n        firstName\\n        email\\n        __typeName\\n        ... on AuthorJson {\\n          joinedAt\\n        }\\n        ... on ContributorJson {\\n          receivedSwag\\n        }\\n        ... on Node {\\n          parent {\\n            id\\n          }\\n        }\\n      }\\n    }\\n  }\\n`\\n\")), mdx(\"p\", null, \"Including the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__typeName\"), \" introspection field allows to check the node type when iterating\\nover the query results in your component:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"data.allTeamMember.nodes.map(node => {\\n  switch (node.__typeName) {\\n    case `AuthorJson`:\\n      return <Author {...node} />\\n    case `ContributorJson`:\\n      return <Contributor {...node} />\\n  }\\n})\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: All types implementing an interface with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@nodeInterface\"), \" extension\\nmust also implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node\"), \" interface.\")), mdx(\"h2\", {\n    \"id\": \"extending-third-party-types\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#extending-third-party-types\",\n    \"aria-label\": \"extending third party types permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Extending third-party types\"), mdx(\"p\", null, \"So far, the examples have been dealing with types created from locally available data.\\nHowever, Gatsby also allows to integrate and modify third-party GraphQL schemas.\"), mdx(\"p\", null, \"Usually, those third-party schemas are retrieved from remote sources via introspection\\nquery with Gatsby\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-graphql\"), \" plugin. To customize types integrated from\\na third-party schema, we can use the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/node-apis/#createResolvers\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"createResolvers\")), \" API.\"), mdx(\"h3\", {\n    \"id\": \"feeding-remote-images-into-gatsby-image\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#feeding-remote-images-into-gatsby-image\",\n    \"aria-label\": \"feeding remote images into gatsby image permalink\",\n    \"className\": \"anchor\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Feeding remote images into \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"gatsby-image\")), mdx(\"p\", null, \"As an example, let\\u2019s look at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/examples/using-gatsby-source-graphql/gatsby-node.js\"\n  }), \"using-gatsby-source-graphql\"), \" to see how we could use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createResolvers\"), \" to feed images from a CMS into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-image\"), \" (the assumption is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-graphql\"), \" was configured\\nto prefix all types from the third-party schema with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CMS\"), \"):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=gatsby-node.js\"\n  }), \"exports.createResolvers = ({\\n  actions,\\n  cache,\\n  createNodeId,\\n  createResolvers,\\n  store,\\n  reporter,\\n}) => {\\n  const { createNode } = actions\\n  createResolvers({\\n    CMS_Asset: {\\n      imageFile: {\\n        type: `File`,\\n        resolve(source, args, context, info) {\\n          return createRemoteFileNode({\\n            url: source.url,\\n            store,\\n            cache,\\n            createNode,\\n            createNodeId,\\n            reporter,\\n          })\\n        },\\n      },\\n    },\\n  })\\n}\\n\")), mdx(\"p\", null, \"We create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"imageFile\"), \" field on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CMS_Asset\"), \" type, which will create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \"\\nnodes from every value on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"url\"), \" field. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" nodes automatically have\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"childImageSharp\"), \" convenience fields available, we can feed the images from the CMS\\ninto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-image\"), \" by simply querying:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  cms {\\n    post {\\n      # In this example, the `post.image` field is of type `CMS_Asset`\\n      image {\\n        # It is important to include all fields in the query which we want to\\n        # access in the resolver. In this example we want to make sure to include\\n        # the `url` field. In the future, Gatsby might provide a `@projection`\\n        # extension to automatically include those fields.\\n        url\\n        imageFile {\\n          childImageSharp {\\n            fixed {\\n              ...GatsbyImageSharpFixed\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;",
        "excerpt": "Customizing the GraphQL Schema One of Gatsby's main strengths is the ability to query data from a variety of\nsources in a uniform way with…",
        "timeToRead": 10,
        "tableOfContents": {
          "items": [
            {
              "url": "#customizing-the-graphql-schema",
              "title": "Customizing the GraphQL Schema",
              "items": [
                {
                  "url": "#explicitly-defining-data-types",
                  "title": "Explicitly defining data types",
                  "items": [
                    {
                      "url": "#the-node-interface",
                      "title": "The Node interface"
                    },
                    {
                      "url": "#automatic-type-inference",
                      "title": "Automatic type inference"
                    },
                    {
                      "url": "#creating-type-definitions",
                      "title": "Creating type definitions",
                      "items": [
                        {
                          "url": "#fixing-field-types",
                          "title": "Fixing field types"
                        },
                        {
                          "url": "#opting-out-of-type-inference",
                          "title": "Opting out of type inference"
                        },
                        {
                          "url": "#nested-types",
                          "title": "Nested types"
                        },
                        {
                          "url": "#gatsby-type-builders",
                          "title": "Gatsby Type Builders"
                        },
                        {
                          "url": "#foreign-key-fields",
                          "title": "Foreign-key fields"
                        },
                        {
                          "url": "#extensions-and-directives",
                          "title": "Extensions and directives"
                        },
                        {
                          "url": "#setting-default-field-values",
                          "title": "Setting default field values"
                        },
                        {
                          "url": "#creating-custom-extensions",
                          "title": "Creating custom extensions"
                        }
                      ]
                    }
                  ]
                },
                {
                  "url": "#createresolvers-api",
                  "title": "createResolvers API",
                  "items": [
                    {
                      "url": "#accessing-gatsbys-data-store-from-field-resolvers",
                      "title": "Accessing Gatsby's data store from field resolvers"
                    },
                    {
                      "url": "#custom-query-fields",
                      "title": "Custom query fields"
                    },
                    {
                      "url": "#taking-care-of-hot-reloading",
                      "title": "Taking care of hot reloading"
                    }
                  ]
                },
                {
                  "url": "#custom-interfaces-and-unions",
                  "title": "Custom Interfaces and Unions",
                  "items": [
                    {
                      "url": "#queryable-interfaces-with-the-nodeinterface-extension",
                      "title": "Queryable interfaces with the @nodeInterface extension"
                    }
                  ]
                },
                {
                  "url": "#extending-third-party-types",
                  "title": "Extending third-party types",
                  "items": [
                    {
                      "url": "#feeding-remote-images-into-gatsby-image",
                      "title": "Feeding remote images into gatsby-image"
                    }
                  ]
                }
              ]
            }
          ]
        },
        "fields": {
          "slug": "/docs/schema-customization/",
          "anchor": "schema-customization"
        },
        "frontmatter": {
          "title": "",
          "overview": null,
          "issue": null,
          "disableTableOfContents": null,
          "tableOfContentsDepth": null
        },
        "parent": {
          "__typename": "File",
          "relativePath": "docs/schema-customization.md"
        }
      }
    },
    "pageContext": {
      "isCreatedByStatefulCreatePages": false,
      "slug": "/docs/schema-customization/",
      "prev": {
        "title": "Node Interface",
        "link": "/docs/node-interface/"
      },
      "next": {
        "title": "API Philosophy",
        "link": "/docs/api-specification/"
      }
    }
  },
  "query": "query usersMisiekDevGatsbyWwwSrcTemplatesTemplateDocsMarkdownJs2546709735(\n  $path: String!\n) {\n  mdx(fields: {slug: {eq: $path}}) {\n    body\n    excerpt\n    timeToRead\n    tableOfContents\n    fields {\n      slug\n      anchor\n    }\n    frontmatter {\n      title\n      overview\n      issue\n      disableTableOfContents\n      tableOfContentsDepth\n    }\n    ...MarkdownPageFooterMdx\n  }\n}\n\nfragment MarkdownPageFooterMdx on Mdx {\n  parent {\n    __typename\n    ... on File {\n      relativePath\n    }\n  }\n}\n"
}